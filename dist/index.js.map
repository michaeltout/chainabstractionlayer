{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@liquality/verus-node-wallet-provider/./lib/VerusNodeWalletProvider.ts","webpack://@liquality/verus-node-wallet-provider/./lib/index.ts","webpack://@liquality/verus-node-wallet-provider/external commonjs \"@liquality/crypto\"","webpack://@liquality/verus-node-wallet-provider/external commonjs \"@liquality/jsonrpc-provider\"","webpack://@liquality/verus-node-wallet-provider/external commonjs \"@liquality/types\"","webpack://@liquality/verus-node-wallet-provider/external commonjs \"@liquality/verus-networks\"","webpack://@liquality/verus-node-wallet-provider/external commonjs \"@liquality/verus-utils\"","webpack://@liquality/verus-node-wallet-provider/external commonjs \"@liquality/wallet-provider\"","webpack://@liquality/verus-node-wallet-provider/external commonjs \"bitcoinjs-lib\"","webpack://@liquality/verus-node-wallet-provider/external commonjs \"lodash\"","webpack://@liquality/verus-node-wallet-provider/webpack/bootstrap","webpack://@liquality/verus-node-wallet-provider/webpack/startup"],"sourcesContent":["import { ECPair, script, Transaction as BitcoinJsTransaction } from 'bitcoinjs-lib'\nimport { uniq, flatten } from 'lodash'\nimport { WalletProvider } from '@liquality/wallet-provider'\nimport { JsonRpcProvider } from '@liquality/jsonrpc-provider'\nimport { verus, SendOptions, BigNumber, Transaction, Address } from '@liquality/types'\nimport { VerusNetworks, VerusNetwork } from '@liquality/verus-networks'\nimport { normalizeTransactionObject, decodeRawTransaction } from '@liquality/verus-utils'\nimport { sha256 } from '@liquality/crypto'\n\nconst CHAIN_TO_NETWORK: { [index: string]: VerusNetwork } = {\n  VRSC: VerusNetworks.verus,\n  VRSCTEST: VerusNetworks.verus_testnet\n}\n\ninterface ProviderOptions {\n  // RPC URI\n  uri: string\n  // Authentication username\n  username?: string\n  // Authentication password\n  password?: string\n  // Bitcoin network\n  network: VerusNetwork\n  // Address type. Default: bech32\n  addressType?: verus.AddressType\n}\n\nexport default class VerusNodeWalletProvider extends WalletProvider {\n  _addressType: verus.AddressType\n  _network: VerusNetwork\n  _rpc: JsonRpcProvider\n  _addressInfoCache: { [key: string]: Address }\n\n  constructor(opts: ProviderOptions) {\n    const { uri, username, password, network, addressType = verus.AddressType.BECH32 } = opts\n    super({ network })\n    const addressTypes = Object.values(verus.AddressType)\n    if (!addressTypes.includes(addressType)) {\n      throw new Error(`addressType must be one of ${addressTypes.join(',')}`)\n    }\n    this._addressType = addressType\n    this._network = network\n    this._rpc = new JsonRpcProvider(uri, username, password)\n    this._addressInfoCache = {}\n  }\n\n  async signMessage(message: string, from: string) {\n    return this._rpc\n      .jsonrpc('signmessage', from, message)\n      .then((result: { hash: string; signature: string }) => Buffer.from(result.signature, 'base64').toString('hex'))\n  }\n\n  canUpdateFee() {\n    return false\n  }\n\n  async withTxFee(func: () => Promise<Transaction<verus.Transaction>>, feePerByte: number) {\n    const feePerKB = new BigNumber(feePerByte).div(1e8).times(1000).toNumber()\n    const originalTxFee: number = (await this._rpc.jsonrpc('getwalletinfo')).paytxfee\n    await this._rpc.jsonrpc('settxfee', feePerKB)\n\n    const result = await func()\n\n    await this._rpc.jsonrpc('settxfee', originalTxFee)\n\n    return result\n  }\n\n  async _sendTransaction(options: SendOptions) {\n    const value = new BigNumber(options.value).dividedBy(1e8).toNumber()\n    const hash = await this._rpc.jsonrpc('sendtoaddress', options.to, value)\n    const transaction = await this._rpc.jsonrpc('gettransaction', hash, true)\n    const fee = new BigNumber(transaction.fee).abs().times(1e8).toNumber()\n    return normalizeTransactionObject(decodeRawTransaction(transaction.hex, this._network), fee)\n  }\n\n  async sendTransaction(options: SendOptions) {\n    return options.fee\n      ? this.withTxFee(async () => this._sendTransaction(options), options.fee)\n      : this._sendTransaction(options)\n  }\n\n  // TODO: Update when Verus adds bumpfee\n  // async updateTransactionFee(tx: Transaction<verus.Transaction>, newFeePerByte: number) {\n  //   const txHash = isString(tx) ? tx : tx.hash\n  //   return this.withTxFee(async () => {\n  //     const result = await this._rpc.jsonrpc('bumpfee', txHash)\n  //     const transaction = await this._rpc.jsonrpc('gettransaction', result.txid, true)\n  //     const fee = new BigNumber(transaction.fee).abs().times(1e8).toNumber()\n  //     return normalizeTransactionObject(decodeRawTransaction(transaction.hex, this._network), fee)\n  //   }, newFeePerByte)\n  // }\n\n  // async signPSBT(data: string, inputs: verus.PsbtInputTarget[]) {\n  //   const psbt = Psbt.fromBase64(data, { network: this._network })\n\n  //   for (const input of inputs) {\n  //     const usedAddresses = await this.getUsedAddresses()\n  //     const address = usedAddresses.find((address) => address.derivationPath === input.derivationPath)\n  //     const wif = await this.dumpPrivKey(address.address)\n  //     const keyPair = ECPair.fromWIF(wif, this._network)\n  //     psbt.signInput(input.index, keyPair)\n  //   }\n\n  //   return psbt.toBase64()\n  // }\n\n  async signBatchP2SHTransaction(\n    inputs: [{ inputTxHex: string; index: number; vout: any; outputScript: Buffer }],\n    addresses: string,\n    tx: any\n  ) {\n    const wallets = []\n    for (const address of addresses) {\n      const wif = await this.dumpPrivKey(address)\n      const wallet = ECPair.fromWIF(wif, this._network)\n      wallets.push(wallet)\n    }\n\n    const sigs = []\n    for (let i = 0; i < inputs.length; i++) {\n      const sigHash = tx.hashForSignature(inputs[i].index, inputs[i].outputScript, BitcoinJsTransaction.SIGHASH_ALL)\n\n      const sig = script.signature.encode(wallets[i].sign(sigHash), BitcoinJsTransaction.SIGHASH_ALL)\n      sigs.push(sig)\n    }\n\n    return sigs\n  }\n\n  async dumpPrivKey(address: string): Promise<string> {\n    return this._rpc.jsonrpc('dumpprivkey', address)\n  }\n\n  async getNewAddress(_addressType: verus.AddressType, label = '') {\n    const params = [label]\n    const newAddress = await this._rpc.jsonrpc('getnewaddress', ...params)\n\n    if (!newAddress) return null\n\n    return this.getAddressInfo(newAddress)\n  }\n\n  async getAddressInfo(address: string): Promise<Address> {\n    if (address in this._addressInfoCache) {\n      return this._addressInfoCache[address]\n    }\n\n    const addressInfo = await this._rpc.jsonrpc('validateaddress', address)\n\n    let publicKey\n\n    if (!addressInfo.iswatchonly) {\n      publicKey = addressInfo.pubkey\n    }\n    const addressObject = new Address({ address, publicKey })\n    this._addressInfoCache[address] = addressObject\n    return addressObject\n  }\n\n  async getAddresses() {\n    return this.getUsedAddresses()\n  }\n\n  async getUnusedAddress() {\n    return this.getNewAddress(this._addressType)\n  }\n\n  async getUsedAddresses() {\n    const usedAddresses: verus.rpc.AddressGrouping[] = await this._rpc.jsonrpc('listaddressgroupings')\n    const emptyAddresses: verus.rpc.ReceivedByAddress[] = await this._rpc.jsonrpc(\n      'listreceivedbyaddress',\n      0,\n      true,\n      false\n    )\n\n    const addrs = uniq([...flatten(usedAddresses).map((addr) => addr[0]), ...emptyAddresses.map((a) => a.address)])\n\n    const addressObjects = await Promise.all(addrs.map((address) => this.getAddressInfo(address)))\n\n    return addressObjects\n  }\n\n  async getWalletAddress(address: string) {\n    return this.getAddressInfo(address)\n  }\n\n  async isWalletAvailable() {\n    try {\n      await this._rpc.jsonrpc('getwalletinfo')\n      return true\n    } catch (e) {\n      return false\n    }\n  }\n\n  async getConnectedNetwork() {\n    const blockchainInfo = await this._rpc.jsonrpc('getinfo')\n    const chain = blockchainInfo.name\n    return CHAIN_TO_NETWORK[chain]\n  }\n\n  async generateSecret(message: string) {\n    const secretAddressLabel = 'secretAddress'\n    let address\n    try {\n      const labelAddresses = await this._rpc.jsonrpc('getaddressesbyaccount', secretAddressLabel)\n      address = Object.keys(labelAddresses)[0]\n    } catch (e) {\n      // Label does not exist\n      address = (await this.getNewAddress(verus.AddressType.LEGACY, secretAddressLabel)).address // Signing only possible with legacy addresses\n    }\n    const signedMessage = await this.signMessage(message, address)\n    const secret = sha256(signedMessage)\n    return secret\n  }\n}\n","import VerusNodeWalletProvider from './VerusNodeWalletProvider'\n\nexport { VerusNodeWalletProvider }\n","module.exports = require(\"@liquality/crypto\");","module.exports = require(\"@liquality/jsonrpc-provider\");","module.exports = require(\"@liquality/types\");","module.exports = require(\"@liquality/verus-networks\");","module.exports = require(\"@liquality/verus-utils\");","module.exports = require(\"@liquality/wallet-provider\");","module.exports = require(\"bitcoinjs-lib\");","module.exports = require(\"lodash\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(175);\n"],"names":["CHAIN_TO_NETWORK","VRSC","VerusNetworks","verus","VRSCTEST","verus_testnet","opts","uri","username","password","network","addressType","AddressType","BECH32","addressTypes","Object","values","includes","Error","join","_addressType","_network","_rpc","JsonRpcProvider","_addressInfoCache","signMessage","message","from","this","jsonrpc","then","result","Buffer","signature","toString","canUpdateFee","withTxFee","func","feePerByte","feePerKB","BigNumber","div","times","toNumber","originalTxFee","paytxfee","_sendTransaction","options","value","dividedBy","to","hash","transaction","fee","abs","normalizeTransactionObject","decodeRawTransaction","hex","sendTransaction","signBatchP2SHTransaction","inputs","addresses","tx","wallets","address","dumpPrivKey","wif","wallet","ECPair","fromWIF","push","sigs","i","length","sigHash","hashForSignature","index","outputScript","SIGHASH_ALL","sig","script","encode","sign","getNewAddress","label","params","newAddress","getAddressInfo","addressInfo","iswatchonly","publicKey","pubkey","addressObject","Address","getAddresses","getUsedAddresses","getUnusedAddress","usedAddresses","emptyAddresses","addrs","uniq","flatten","map","addr","a","Promise","all","getWalletAddress","isWalletAvailable","getConnectedNetwork","blockchainInfo","chain","name","generateSecret","secretAddressLabel","labelAddresses","keys","LEGACY","signedMessage","sha256","WalletProvider","VerusNodeWalletProvider","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}