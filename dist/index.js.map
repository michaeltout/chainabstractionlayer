{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@liquality/verus-wallet-provider/./lib/VerusWalletProvider.ts","webpack://@liquality/verus-wallet-provider/./lib/index.ts","webpack://@liquality/verus-wallet-provider/external commonjs \"@bitgo/utxo-lib\"","webpack://@liquality/verus-wallet-provider/external commonjs \"@liquality/errors\"","webpack://@liquality/verus-wallet-provider/external commonjs \"@liquality/types\"","webpack://@liquality/verus-wallet-provider/external commonjs \"@liquality/utils\"","webpack://@liquality/verus-wallet-provider/external commonjs \"@liquality/verus-utils\"","webpack://@liquality/verus-wallet-provider/external commonjs \"bitcoinjs-lib\"","webpack://@liquality/verus-wallet-provider/external commonjs \"memoizee\"","webpack://@liquality/verus-wallet-provider/webpack/bootstrap","webpack://@liquality/verus-wallet-provider/webpack/startup"],"sourcesContent":["import { selectCoins, normalizeTransactionObject, decodeRawTransaction, CoinSelectTarget } from '@liquality/verus-utils'\nimport { VerusNetwork } from '@liquality/verus-networks'\nimport { verus, Transaction, Address, BigNumber, SendOptions, ChainProvider, WalletProvider } from '@liquality/types'\nimport { asyncSetImmediate, addressToString } from '@liquality/utils'\nimport { Provider } from '@liquality/provider'\nimport { InsufficientBalanceError } from '@liquality/errors'\nimport { BIP32Interface, script } from 'bitcoinjs-lib'\nimport memoize from 'memoizee'\n\nconst bitgo = require('@bitgo/utxo-lib') // eslint-disable-line\n\nconst ADDRESS_GAP = 20\n\nexport enum AddressSearchType {\n  EXTERNAL,\n  CHANGE,\n  EXTERNAL_OR_CHANGE\n}\n\ntype DerivationCache = { [index: string]: Address }\n\ntype Constructor<T = unknown> = new (...args: any[]) => T\n\ninterface VerusWalletProviderOptions {\n  network: VerusNetwork\n  baseDerivationPath: string\n  addressType?: verus.AddressType\n}\n\nexport default <T extends Constructor<Provider>>(superclass: T) => {\n  abstract class VerusWalletProvider extends superclass implements Partial<ChainProvider>, Partial<WalletProvider> {\n    _baseDerivationPath: string\n    _network: VerusNetwork\n    _addressType: verus.AddressType\n    _derivationCache: DerivationCache\n\n    constructor(...args: any[]) {\n      const options = args[0] as VerusWalletProviderOptions\n      const { network, baseDerivationPath, addressType = verus.AddressType.BECH32 } = options\n      const addressTypes = Object.values(verus.AddressType)\n      if (!addressTypes.includes(addressType)) {\n        throw new Error(`addressType must be one of ${addressTypes.join(',')}`)\n      }\n\n      super(options)\n\n      this._baseDerivationPath = baseDerivationPath\n      this._network = network\n      this._addressType = addressType\n      this._derivationCache = {}\n    }\n\n    abstract baseDerivationNode(): Promise<BIP32Interface>\n    abstract _buildTransaction(\n      targets: verus.OutputTarget[],\n      feePerByte?: number,\n      fixedInputs?: verus.Input[]\n    ): Promise<{ hex: string; fee: number }>\n    abstract _buildSweepTransaction(\n      externalChangeAddress: string,\n      feePerByte?: number\n    ): Promise<{ hex: string; fee: number }>\n    abstract signPSBT(data: string, inputs: verus.PsbtInputTarget[]): Promise<string>\n    abstract signBatchP2SHTransaction(\n      inputs: [{ inputTxHex: string; index: number; vout: any; outputScript: Buffer }],\n      addresses: string,\n      tx: any,\n      lockTime?: number,\n      segwit?: boolean\n    ): Promise<Buffer[]>\n\n    getDerivationCache() {\n      return this._derivationCache\n    }\n\n    sendOptionsToOutputs(transactions: SendOptions[]): verus.OutputTarget[] {\n      const targets: verus.OutputTarget[] = []\n\n      transactions.forEach((tx) => {\n        if (tx.to && tx.value && tx.value.gt(0)) {\n          targets.push({\n            address: addressToString(tx.to),\n            value: tx.value.toNumber()\n          })\n        }\n\n        if (tx.data) {\n          const scriptBuffer = script.compile([script.OPS.OP_RETURN, Buffer.from(tx.data, 'hex')])\n          targets.push({\n            value: 0,\n            script: scriptBuffer\n          })\n        }\n      })\n\n      return targets\n    }\n\n    async setDerivationCache(derivationCache: DerivationCache) {\n      const address = await this.getDerivationPathAddress(Object.keys(derivationCache)[0])\n      if (derivationCache[address.derivationPath].address !== address.address) {\n        throw new Error(`derivationCache at ${address.derivationPath} does not match`)\n      }\n      this._derivationCache = derivationCache\n    }\n\n    async buildTransaction(output: verus.OutputTarget, feePerByte: number) {\n      return this._buildTransaction([output], feePerByte)\n    }\n\n    async buildBatchTransaction(outputs: verus.OutputTarget[]) {\n      return this._buildTransaction(outputs)\n    }\n\n    async _sendTransaction(transactions: verus.OutputTarget[], feePerByte?: number) {\n      const { hex, fee } = await this._buildTransaction(transactions, feePerByte)\n      await this.getMethod('sendRawTransaction')(hex)\n      return normalizeTransactionObject(decodeRawTransaction(hex, this._network), fee)\n    }\n\n    async sendTransaction(options: SendOptions) {\n      return this._sendTransaction(this.sendOptionsToOutputs([options]), options.fee)\n    }\n\n    async sendBatchTransaction(transactions: SendOptions[]) {\n      return this._sendTransaction(this.sendOptionsToOutputs(transactions))\n    }\n\n    async buildSweepTransaction(externalChangeAddress: string, feePerByte: number) {\n      return this._buildSweepTransaction(externalChangeAddress, feePerByte)\n    }\n\n    async sendSweepTransaction(externalChangeAddress: Address | string, feePerByte: number) {\n      const { hex, fee } = await this._buildSweepTransaction(addressToString(externalChangeAddress), feePerByte)\n      await this.getMethod('sendRawTransaction')(hex)\n      return normalizeTransactionObject(decodeRawTransaction(hex, this._network), fee)\n    }\n\n    async updateTransactionFee(tx: Transaction<verus.Transaction> | string, newFeePerByte: number) {\n      const txHash = typeof tx === 'string' ? tx : tx.hash\n      const transaction: verus.Transaction = (await this.getMethod('getTransactionByHash')(txHash))._raw\n      const fixedInputs = [transaction.vin[0]] // TODO: should this pick more than 1 input? RBF doesn't mandate it\n\n      const lookupAddresses = transaction.vout.map((vout) => vout.scriptPubKey.addresses[0])\n      const changeAddress = await this.findAddress(lookupAddresses, true)\n      const changeOutput = transaction.vout.find((vout) => vout.scriptPubKey.addresses[0] === changeAddress.address)\n\n      let outputs = transaction.vout\n      if (changeOutput) {\n        outputs = outputs.filter((vout) => vout.scriptPubKey.addresses[0] !== changeOutput.scriptPubKey.addresses[0])\n      }\n\n      // TODO more checks?\n      const transactions = outputs.map((output) => ({\n        address: output.scriptPubKey.addresses[0],\n        value: new BigNumber(output.value).times(1e8).toNumber()\n      }))\n      const { hex, fee } = await this._buildTransaction(transactions, newFeePerByte, fixedInputs)\n      await this.getMethod('sendRawTransaction')(hex)\n      return normalizeTransactionObject(decodeRawTransaction(hex, this._network), fee)\n    }\n\n    async findAddress(addresses: string[], change = false) {\n      // A maximum number of addresses to lookup after which it is deemed that the wallet does not contain this address\n      const maxAddresses = 5000\n      const addressesPerCall = 50\n      let index = 0\n      while (index < maxAddresses) {\n        const walletAddresses = await this.getAddresses(index, addressesPerCall, change)\n        const walletAddress = walletAddresses.find((walletAddr) =>\n          addresses.find((addr) => walletAddr.address === addr)\n        )\n        if (walletAddress) return walletAddress\n        index += addressesPerCall\n      }\n    }\n\n    async getWalletAddress(address: string) {\n      const externalAddress = await this.findAddress([address], false)\n      if (externalAddress) return externalAddress\n      const changeAddress = await this.findAddress([address], true)\n      if (changeAddress) return changeAddress\n\n      throw new Error('Wallet does not contain address')\n    }\n\n    getAddressFromPublicKey(publicKey: Buffer) {\n      return bitgo.ECPair.fromPublicKeyBuffer(publicKey, bitgo.networks[this._network.bitgokey]).getAddress()\n    }\n\n    async importAddresses() {\n      const change = await this.getAddresses(0, 200, true)\n      const nonChange = await this.getAddresses(0, 200, false)\n      const all = [...nonChange, ...change].map((address) => address.address)\n      await this.getMethod('importAddresses')(all)\n    }\n\n    async getDerivationPathAddress(path: string) {\n      if (path in this._derivationCache) {\n        return this._derivationCache[path]\n      }\n\n      const baseDerivationNode = await this.baseDerivationNode()\n      const subPath = path.replace(this._baseDerivationPath + '/', '')\n      const publicKey = baseDerivationNode.derivePath(subPath).publicKey\n      const address = this.getAddressFromPublicKey(publicKey)\n      const addressObject = new Address({\n        address,\n        publicKey: publicKey.toString('hex'),\n        derivationPath: path\n      })\n\n      this._derivationCache[path] = addressObject\n      return addressObject\n    }\n\n    async getAddresses(startingIndex = 0, numAddresses = 1, change = false) {\n      if (numAddresses < 1) {\n        throw new Error('You must return at least one address')\n      }\n\n      const addresses = []\n      const lastIndex = startingIndex + numAddresses\n      const changeVal = change ? '1' : '0'\n\n      for (let currentIndex = startingIndex; currentIndex < lastIndex; currentIndex++) {\n        const subPath = changeVal + '/' + currentIndex\n        const path = this._baseDerivationPath + '/' + subPath\n        const addressObject = await this.getDerivationPathAddress(path)\n        addresses.push(addressObject)\n\n        await asyncSetImmediate()\n      }\n\n      return addresses\n    }\n\n    async _getUsedUnusedAddresses(numAddressPerCall = 100, addressType: AddressSearchType) {\n      const usedAddresses = []\n      const addressCountMap = { change: 0, external: 0 }\n      const unusedAddressMap: { change: Address; external: Address } = { change: null, external: null }\n\n      let addrList: Address[]\n      let addressIndex = 0\n      let changeAddresses: Address[] = []\n      let externalAddresses: Address[] = []\n\n      /* eslint-disable no-unmodified-loop-condition */\n      while (\n        (addressType === AddressSearchType.EXTERNAL_OR_CHANGE &&\n          (addressCountMap.change < ADDRESS_GAP || addressCountMap.external < ADDRESS_GAP)) ||\n        (addressType === AddressSearchType.EXTERNAL && addressCountMap.external < ADDRESS_GAP) ||\n        (addressType === AddressSearchType.CHANGE && addressCountMap.change < ADDRESS_GAP)\n      ) {\n        /* eslint-enable no-unmodified-loop-condition */\n        addrList = []\n\n        if (\n          (addressType === AddressSearchType.EXTERNAL_OR_CHANGE || addressType === AddressSearchType.CHANGE) &&\n          addressCountMap.change < ADDRESS_GAP\n        ) {\n          // Scanning for change addr\n          changeAddresses = await this.getAddresses(addressIndex, numAddressPerCall, true)\n          addrList = addrList.concat(changeAddresses)\n        } else {\n          changeAddresses = []\n        }\n\n        if (\n          (addressType === AddressSearchType.EXTERNAL_OR_CHANGE || addressType === AddressSearchType.EXTERNAL) &&\n          addressCountMap.external < ADDRESS_GAP\n        ) {\n          // Scanning for non change addr\n          externalAddresses = await this.getAddresses(addressIndex, numAddressPerCall, false)\n          addrList = addrList.concat(externalAddresses)\n        }\n\n        const addressDeltas: verus.AddressDeltas = await this.getMethod('getAddressDeltas')(addrList)\n\n        for (const address of addrList) {\n          const isUsed = addressDeltas[address.address].length > 0\n          const isChangeAddress = changeAddresses.find((a) => address.address === a.address)\n          const key = isChangeAddress ? 'change' : 'external'\n\n          if (isUsed) {\n            usedAddresses.push(address)\n            addressCountMap[key] = 0\n            unusedAddressMap[key] = null\n          } else {\n            addressCountMap[key]++\n\n            if (!unusedAddressMap[key]) {\n              unusedAddressMap[key] = address\n            }\n          }\n        }\n\n        addressIndex += numAddressPerCall\n      }\n\n      return {\n        usedAddresses,\n        unusedAddress: unusedAddressMap\n      }\n    }\n\n    async getUsedAddresses(numAddressPerCall = 100) {\n      return this._getUsedUnusedAddresses(numAddressPerCall, AddressSearchType.EXTERNAL_OR_CHANGE).then(\n        ({ usedAddresses }) => usedAddresses\n      )\n    }\n\n    async getUnusedAddress(change = false, numAddressPerCall = 100) {\n      const addressType = change ? AddressSearchType.CHANGE : AddressSearchType.EXTERNAL\n      const key = change ? 'change' : 'external'\n      return this._getUsedUnusedAddresses(numAddressPerCall, addressType).then(\n        ({ unusedAddress }) => unusedAddress[key]\n      )\n    }\n\n    async withCachedUtxos(func: () => any) {\n      const originalGetMethod = this.getMethod\n      const memoizedGetFeePerByte = memoize(this.getMethod('getFeePerByte'), { primitive: true })\n      const memoizedGetUnspentTransactions = memoize(this.getMethod('getUnspentTransactions'), { primitive: true })\n      const memoizedGetAddressDeltas = memoize(this.getMethod('getAddressDeltas'), {\n        primitive: true\n      })\n      this.getMethod = (method: string, requestor: any = this) => {\n        if (method === 'getFeePerByte') return memoizedGetFeePerByte\n        if (method === 'getUnspentTransactions') return memoizedGetUnspentTransactions\n        else if (method === 'getAddressDeltas') return memoizedGetAddressDeltas\n        else return originalGetMethod.bind(this)(method, requestor)\n      }\n\n      const result = await func.bind(this)()\n\n      this.getMethod = originalGetMethod\n\n      return result\n    }\n\n    async getTotalFee(opts: SendOptions, max: boolean) {\n      const targets = this.sendOptionsToOutputs([opts])\n      if (!max) {\n        const { fee } = await this.getInputsForAmount(targets, opts.fee)\n        return fee\n      } else {\n        const { fee } = await this.getInputsForAmount(\n          targets.filter((t) => !t.value),\n          opts.fee,\n          [],\n          100,\n          true\n        )\n        return fee\n      }\n    }\n\n    async getTotalFees(transactions: SendOptions[], max: boolean) {\n      const fees = await this.withCachedUtxos(async () => {\n        const fees: { [index: number]: BigNumber } = {}\n        for (const tx of transactions) {\n          const fee = await this.getTotalFee(tx, max)\n          fees[tx.fee] = new BigNumber(fee)\n        }\n        return fees\n      })\n      return fees\n    }\n\n    async getInputsForAmount(\n      _targets: verus.OutputTarget[],\n      feePerByte?: number,\n      fixedInputs: verus.Input[] = [],\n      numAddressPerCall = 100,\n      sweep = false\n    ) {\n      let addressIndex = 0\n      let changeAddresses: Address[] = []\n      let externalAddresses: Address[] = []\n      const addressCountMap = {\n        change: 0,\n        nonChange: 0\n      }\n\n      const feePerBytePromise = this.getMethod('getFeePerByte')()\n      let utxos: verus.UTXO[] = []\n\n      while (addressCountMap.change < ADDRESS_GAP || addressCountMap.nonChange < ADDRESS_GAP) {\n        let addrList: Address[] = []\n\n        if (addressCountMap.change < ADDRESS_GAP) {\n          // Scanning for change addr\n          changeAddresses = await this.getAddresses(addressIndex, numAddressPerCall, true)\n          addrList = addrList.concat(changeAddresses)\n        } else {\n          changeAddresses = []\n        }\n\n        if (addressCountMap.nonChange < ADDRESS_GAP) {\n          // Scanning for non change addr\n          externalAddresses = await this.getAddresses(addressIndex, numAddressPerCall, false)\n          addrList = addrList.concat(externalAddresses)\n        }\n\n        const fixedUtxos: verus.UTXO[] = []\n        if (fixedInputs.length > 0) {\n          for (const input of fixedInputs) {\n            const txHex = await this.getMethod('getRawTransactionByHash')(input.txid)\n            const tx = decodeRawTransaction(txHex, this._network)\n            const value = new BigNumber(tx.vout[input.vout].value).times(1e8).toNumber()\n            const address = tx.vout[input.vout].scriptPubKey.addresses[0]\n            const walletAddress = await this.getWalletAddress(address)\n            const utxo = { ...input, value, address, derivationPath: walletAddress.derivationPath }\n            fixedUtxos.push(utxo)\n          }\n        }\n\n        if (!sweep || fixedUtxos.length === 0) {\n          const _utxos: verus.UTXO[] = await this.getMethod('getUnspentTransactions')(addrList)\n          utxos.push(\n            ..._utxos.map((utxo) => {\n              const addr = addrList.find((a) => a.address === utxo.address)\n              return {\n                ...utxo,\n                derivationPath: addr.derivationPath\n              }\n            })\n          )\n        } else {\n          utxos = fixedUtxos\n        }\n\n        const utxoBalance = utxos.reduce((a, b) => a + (b.value || 0), 0)\n\n        const addressDeltas: verus.AddressDeltas = await this.getMethod('getAddressDeltas')(addrList)\n\n        if (!feePerByte) feePerByte = await feePerBytePromise\n        const minRelayFee = await this.getMethod('getMinRelayFee')()\n        if (feePerByte < minRelayFee) {\n          throw new Error(`Fee supplied (${feePerByte} sat/b) too low. Minimum relay fee is ${minRelayFee} sat/b`)\n        }\n\n        let targets: CoinSelectTarget[]\n        if (sweep) {\n          const outputBalance = _targets.reduce((a, b) => a + (b['value'] || 0), 0)\n\n          const sweepOutputSize = 39\n          const paymentOutputSize = _targets.filter((t) => t.value && t.address).length * 39\n          const scriptOutputSize = _targets\n            .filter((t) => !t.value && t.script)\n            .reduce((size, t) => size + 39 + t.script.byteLength, 0)\n\n          const outputSize = sweepOutputSize + paymentOutputSize + scriptOutputSize\n          const inputSize = utxos.length * 153\n\n          const sweepFee = feePerByte * (inputSize + outputSize)\n          const amountToSend = new BigNumber(utxoBalance).minus(sweepFee)\n\n          targets = _targets.map((target) => ({ id: 'main', value: target.value, script: target.script }))\n          targets.push({ id: 'main', value: amountToSend.minus(outputBalance).toNumber() })\n        } else {\n          targets = _targets.map((target) => ({ id: 'main', value: target.value, script: target.script }))\n        }\n\n        const { inputs, outputs, change, fee } = selectCoins(utxos, targets, Math.ceil(feePerByte), fixedUtxos)\n\n        if (inputs && outputs) {\n          return {\n            inputs,\n            change,\n            outputs,\n            fee\n          }\n        }\n\n        for (const address of addrList) {\n          const isUsed = addressDeltas[address.address].length > 0\n          const isChangeAddress = changeAddresses.find((a) => address.address === a.address)\n          const key = isChangeAddress ? 'change' : 'nonChange'\n\n          if (isUsed) {\n            addressCountMap[key] = 0\n          } else {\n            addressCountMap[key]++\n          }\n        }\n\n        addressIndex += numAddressPerCall\n      }\n\n      throw new InsufficientBalanceError('Not enough balance')\n    }\n  }\n  return VerusWalletProvider\n}\n","import VerusWalletProvider from './VerusWalletProvider'\n\nexport { VerusWalletProvider }\n","module.exports = require(\"@bitgo/utxo-lib\");","module.exports = require(\"@liquality/errors\");","module.exports = require(\"@liquality/types\");","module.exports = require(\"@liquality/utils\");","module.exports = require(\"@liquality/verus-utils\");","module.exports = require(\"bitcoinjs-lib\");","module.exports = require(\"memoizee\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(175);\n"],"names":["AddressSearchType","bitgo","ADDRESS_GAP","superclass","options","args","network","baseDerivationPath","addressType","verus","AddressType","BECH32","addressTypes","Object","values","includes","Error","join","_baseDerivationPath","_network","_addressType","_derivationCache","getDerivationCache","this","sendOptionsToOutputs","transactions","targets","forEach","tx","to","value","gt","push","address","addressToString","toNumber","data","scriptBuffer","script","compile","OPS","OP_RETURN","Buffer","from","setDerivationCache","derivationCache","getDerivationPathAddress","keys","derivationPath","buildTransaction","output","feePerByte","_buildTransaction","buildBatchTransaction","outputs","_sendTransaction","hex","fee","getMethod","normalizeTransactionObject","decodeRawTransaction","sendTransaction","sendBatchTransaction","buildSweepTransaction","externalChangeAddress","_buildSweepTransaction","sendSweepTransaction","updateTransactionFee","newFeePerByte","txHash","hash","transaction","_raw","fixedInputs","vin","lookupAddresses","vout","map","scriptPubKey","addresses","findAddress","changeAddress","changeOutput","find","filter","BigNumber","times","change","maxAddresses","addressesPerCall","index","getAddresses","walletAddresses","walletAddress","walletAddr","addr","getWalletAddress","externalAddress","getAddressFromPublicKey","publicKey","ECPair","fromPublicKeyBuffer","networks","bitgokey","getAddress","importAddresses","nonChange","all","path","baseDerivationNode","subPath","replace","derivePath","addressObject","Address","toString","startingIndex","numAddresses","lastIndex","changeVal","currentIndex","asyncSetImmediate","_getUsedUnusedAddresses","numAddressPerCall","usedAddresses","addressCountMap","external","unusedAddressMap","addressIndex","changeAddresses","externalAddresses","EXTERNAL_OR_CHANGE","EXTERNAL","CHANGE","addrList","concat","addressDeltas","isUsed","length","key","a","unusedAddress","getUsedAddresses","then","getUnusedAddress","withCachedUtxos","func","originalGetMethod","memoizedGetFeePerByte","primitive","memoizedGetUnspentTransactions","memoizedGetAddressDeltas","method","requestor","bind","result","getTotalFee","opts","max","getInputsForAmount","t","getTotalFees","fees","_targets","sweep","feePerBytePromise","utxos","fixedUtxos","input","txid","txHex","utxo","_utxos","utxoBalance","reduce","b","minRelayFee","outputBalance","paymentOutputSize","scriptOutputSize","size","byteLength","outputSize","inputSize","sweepFee","amountToSend","minus","target","id","selectCoins","Math","ceil","inputs","InsufficientBalanceError","VerusWalletProvider","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}