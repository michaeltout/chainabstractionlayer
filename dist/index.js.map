{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@liquality/verus-rpc-provider/./lib/VerusRpcProvider.ts","webpack://@liquality/verus-rpc-provider/./lib/index.ts","webpack://@liquality/verus-rpc-provider/external commonjs \"@liquality/errors\"","webpack://@liquality/verus-rpc-provider/external commonjs \"@liquality/jsonrpc-provider\"","webpack://@liquality/verus-rpc-provider/external commonjs \"@liquality/types\"","webpack://@liquality/verus-rpc-provider/external commonjs \"@liquality/utils\"","webpack://@liquality/verus-rpc-provider/external commonjs \"@liquality/verus-utils\"","webpack://@liquality/verus-rpc-provider/external commonjs \"lodash\"","webpack://@liquality/verus-rpc-provider/webpack/bootstrap","webpack://@liquality/verus-rpc-provider/webpack/startup"],"sourcesContent":["import { JsonRpcProvider } from '@liquality/jsonrpc-provider'\nimport { addressToString } from '@liquality/utils'\nimport { normalizeTransactionObject, decodeRawTransaction } from '@liquality/verus-utils'\nimport { TxNotFoundError, BlockNotFoundError } from '@liquality/errors'\nimport { BitcoinNetwork } from '@liquality/bitcoin-networks'\nimport { verus, Transaction, Block, ChainProvider, SendOptions, Address, BigNumber } from '@liquality/types'\n\nimport { flatten } from 'lodash'\n\ninterface ProviderOptions {\n  // RPC URI\n  uri: string\n  // Authentication username\n  username?: string\n  // Authentication password\n  password?: string\n  // Bitcoin network\n  network: BitcoinNetwork\n  // Number of block confirmations to target for fee. Defaul: 1\n  feeBlockConfirmations?: number\n  // Default fee per byte for transactions. Default: 3\n  defaultFeePerByte?: number\n}\n\nexport default class BitcoinRpcProvider extends JsonRpcProvider implements Partial<ChainProvider> {\n  _feeBlockConfirmations: number\n  _defaultFeePerByte: number\n  _network: BitcoinNetwork\n  _usedAddressCache: { [key: string]: boolean }\n\n  constructor(options: ProviderOptions) {\n    const { uri, username, password, network, feeBlockConfirmations = 1, defaultFeePerByte = 3 } = options\n    super(uri, username, password)\n    this._network = network\n    this._feeBlockConfirmations = feeBlockConfirmations\n    this._defaultFeePerByte = defaultFeePerByte\n    this._usedAddressCache = {}\n  }\n\n  async decodeRawTransaction(rawTransaction: string): Promise<verus.Transaction> {\n    return this.jsonrpc('decoderawtransaction', rawTransaction)\n  }\n\n  async getFeePerByte(numberOfBlocks = this._feeBlockConfirmations) {\n    try {\n      const fee = await this.jsonrpc('estimatefee', numberOfBlocks)\n\n      if (fee && fee > 0) {\n        // Get satoshis per byte (* 100000000 / 1000)\n        return new BigNumber(fee).times(1e5).toNumber()\n      }\n\n      throw new Error('Invalid estimated fee')\n    } catch (e) {\n      return this._defaultFeePerByte\n    }\n  }\n\n  async getMinRelayFee() {\n    const { relayfee } = await this.jsonrpc('getnetworkinfo')\n    return (relayfee * 1e8) / 1000\n  }\n\n  async getBalance(_addresses: (string | Address)[]) {\n    const addresses = _addresses.map(addressToString)\n    const _utxos = await this.getUnspentTransactions(addresses)\n    const utxos = flatten(_utxos)\n\n    return utxos.reduce((acc, utxo) => acc.plus(utxo.value), new BigNumber(0))\n  }\n\n  async getUnspentTransactions(_addresses: (Address | string)[]): Promise<verus.UTXO[]> {\n    const addresses = _addresses.map(addressToString)\n    const utxos: verus.rpc.UTXO[] = await this.jsonrpc('listunspent', 0, 9999999, addresses)\n    return utxos.map((utxo) => ({ ...utxo, value: new BigNumber(utxo.amount).times(1e8).toNumber() }))\n  }\n\n  async getAddressTransactionCounts(_addresses: (Address | string)[]) {\n    const addresses = _addresses.map(addressToString)\n    const receivedAddresses: verus.rpc.ReceivedByAddress[] = await this.jsonrpc('listreceivedbyaddress', 0, false, true)\n    return addresses.reduce((acc: verus.AddressTxCounts, addr) => {\n      const receivedAddress = receivedAddresses.find((receivedAddress) => receivedAddress.address === addr)\n      const transactionCount = receivedAddress ? receivedAddress.txids.length : 0\n      acc[addr] = transactionCount\n      return acc\n    }, {})\n  }\n\n  async getAddressDeltas(_addresses: (Address | string)[]) {\n    const addresses = _addresses.map(addressToString)\n    const addressDeltas: verus.rpc.AddressDelta[] = await this.jsonrpc('getaddressdeltas', { addresses })\n    let deltasFormatted: verus.AddressDeltas = {}\n\n    for (const address of addresses) {\n      deltasFormatted[address] = []\n    }\n\n    for (const delta of addressDeltas) {\n      if (deltasFormatted[delta.address]) deltasFormatted[delta.address].push(delta)\n      else deltasFormatted[delta.address] = [delta]\n    }\n\n    return deltasFormatted\n  }\n\n  async getReceivedByAddress(address: string): Promise<number> {\n    return this.jsonrpc('getreceivedbyaddress', address)\n  }\n\n  async importAddresses(addresses: string[]) {\n    const request = addresses.map((address) => ({ scriptPubKey: { address }, timestamp: 0 }))\n    return this.jsonrpc('importmulti', request)\n  }\n\n  async getTransactionHex(transactionHash: string): Promise<string> {\n    return this.jsonrpc('getrawtransaction', transactionHash)\n  }\n\n  async generateBlock(numberOfBlocks: number): Promise<void> {\n    let lastLongest = -1;\n    let blocksPassed = 0;\n\n    return new Promise((resolve, reject) => {\n      // Actually waits for new block(s)\n      const infoInterval = setInterval(async () => {\n        try {\n          const { longestchain } = await this.jsonrpc('getinfo')\n\n          if (lastLongest === -1) lastLongest = longestchain\n          else if (longestchain > lastLongest) {\n            blocksPassed += longestchain - lastLongest\n            lastLongest = longestchain\n          }\n\n          if (blocksPassed >= numberOfBlocks) {\n            clearInterval(infoInterval)\n            resolve(null)\n          }\n        } catch (e) {\n          clearInterval(infoInterval)\n          reject(e)\n        }\n      }, 1000)\n    })\n  }\n\n  async getBlockByHash(blockHash: string, includeTx = false): Promise<Block> {\n    let data: verus.rpc.Block\n\n    try {\n      data = await this.jsonrpc('getblock', blockHash) // TODO: This doesn't fit the interface?: https://chainquery.com/bitcoin-cli/getblock\n    } catch (e) {\n      if (e.name === 'NodeError' && e.message.includes('Block not found')) {\n        const { name, message, ...attrs } = e\n        throw new BlockNotFoundError(`Block not found: ${blockHash}`, attrs)\n      }\n\n      throw e\n    }\n\n    const {\n      hash,\n      height: number,\n      time: timestamp,\n      difficulty,\n      size,\n      previousblockhash: parentHash,\n      nonce,\n      tx: transactionHashes\n    } = data\n\n    let transactions: any[] = transactionHashes\n    // TODO: Why transactions need to be retrieved individually? getblock has verbose 2 https://chainquery.com/bitcoin-cli/getblock\n    if (includeTx) {\n      const txs = transactionHashes.map((hash) => this.getTransactionByHash(hash))\n      transactions = await Promise.all(txs)\n    }\n\n    return {\n      hash,\n      number,\n      timestamp,\n      difficulty: parseFloat(new BigNumber(difficulty).toFixed()),\n      size,\n      parentHash,\n      nonce,\n      transactions\n    }\n  }\n\n  async getBlockByNumber(blockNumber: number, includeTx = false) {\n    let blockHash\n\n    try {\n      blockHash = await this.jsonrpc('getblockhash', blockNumber)\n    } catch (e) {\n      if (e.name === 'NodeError' && e.message.includes('Block height out of range')) {\n        const { name, message, ...attrs } = e\n        throw new BlockNotFoundError(`Block not found: ${blockNumber}`, attrs)\n      }\n\n      throw e\n    }\n\n    return this.getBlockByHash(blockHash, includeTx)\n  }\n\n  async getBlockHeight() {\n    return this.jsonrpc('getblockcount')\n  }\n\n  async getTransactionByHash(transactionHash: string) {\n    try {\n      const tx = await this.getParsedTransactionByHash(transactionHash, true)\n      return tx\n    } catch (e) {\n      if (e.name === 'NodeError' && e.message.includes('No such mempool transaction')) {\n        const { name, message, ...attrs } = e\n        throw new TxNotFoundError(`Transaction not found: ${transactionHash}`, attrs)\n      }\n\n      throw e\n    }\n  }\n\n  async getTransactionFee(tx: verus.Transaction) {\n    const isCoinbaseTx = tx.vin.find((vin) => vin.coinbase)\n    if (isCoinbaseTx) return // Coinbase transactions do not have a fee\n\n    const inputs = tx.vin.map((vin) => ({ txid: vin.txid, vout: vin.vout }))\n    const inputTransactions = await Promise.all(inputs.map((input) => this.jsonrpc('getrawtransaction', input.txid, 1)))\n\n    const inputValues = inputTransactions.map((inputTx, index) => {\n      const vout = inputs[index].vout\n      const output = inputTx.vout[vout]\n      return output.value * 1e8\n    })\n    const inputValue = inputValues.reduce((a, b) => a.plus(new BigNumber(b)), new BigNumber(0))\n    const outputValue = tx.vout.reduce(\n      (a, b) => a.plus(new BigNumber(b.value).times(new BigNumber(1e8))),\n      new BigNumber(0)\n    )\n    const feeValue = inputValue.minus(outputValue)\n    return feeValue.toNumber()\n  }\n\n  async getParsedTransactionByHash(transactionHash: string, addFees = false): Promise<Transaction<verus.Transaction>> {\n    const tx: verus.rpc.MinedTransaction = await this.jsonrpc('getrawtransaction', transactionHash, 1)\n    return normalizeTransactionObject(\n      tx,\n      addFees ? await this.getTransactionFee(tx) : undefined,\n      tx.confirmations > 0 ? await this.getBlockByHash(tx.blockhash) : undefined\n    )\n  }\n\n  async getRawTransactionByHash(transactionHash: string) {\n    const tx: string = await this.jsonrpc('getrawtransaction', transactionHash, 0)\n    return tx\n  }\n\n  async sendRawTransaction(rawTransaction: string): Promise<string> {\n    return this.jsonrpc('sendrawtransaction', rawTransaction)\n  }\n\n  async sendBatchTransaction(transactions: SendOptions[]) {\n    const outputs: { [index: string]: number } = {}\n    for (const tx of transactions) {\n      outputs[addressToString(tx.to)] = new BigNumber(tx.value).dividedBy(1e8).toNumber()\n    }\n    const rawTxOutputs = await this.createRawTransaction([], outputs)\n    const rawTxFunded = await this.fundRawTransaction(rawTxOutputs)\n    const rawTxSigned = await this.signRawTransaction(rawTxFunded.hex)\n    const fee = new BigNumber(rawTxFunded.fee).times(1e8).toNumber()\n    await this.sendRawTransaction(rawTxSigned.hex)\n    return normalizeTransactionObject(decodeRawTransaction(rawTxSigned.hex, this._network), fee)\n  }\n\n  async signRawTransaction(hexstring: string) {\n    return this.jsonrpc('signrawtransactionwithwallet', hexstring)\n  }\n\n  async createRawTransaction(transactions: [], outputs: { [index: string]: number }): Promise<string> {\n    return this.jsonrpc('createrawtransaction', transactions, outputs)\n  }\n\n  async fundRawTransaction(hexstring: string): Promise<verus.rpc.FundRawResponse> {\n    return this.jsonrpc('fundrawtransaction', hexstring)\n  }\n}\n","import VerusRpcProvider from './VerusRpcProvider'\n\nexport { VerusRpcProvider }\n","module.exports = require(\"@liquality/errors\");","module.exports = require(\"@liquality/jsonrpc-provider\");","module.exports = require(\"@liquality/types\");","module.exports = require(\"@liquality/utils\");","module.exports = require(\"@liquality/verus-utils\");","module.exports = require(\"lodash\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(175);\n"],"names":["options","uri","username","password","network","feeBlockConfirmations","defaultFeePerByte","_network","_feeBlockConfirmations","_defaultFeePerByte","_usedAddressCache","decodeRawTransaction","rawTransaction","this","jsonrpc","getFeePerByte","numberOfBlocks","fee","BigNumber","times","toNumber","Error","getMinRelayFee","getBalance","_addresses","addresses","map","addressToString","getUnspentTransactions","_utxos","flatten","reduce","acc","utxo","plus","value","amount","getAddressTransactionCounts","receivedAddresses","addr","receivedAddress","find","address","transactionCount","txids","length","getAddressDeltas","addressDeltas","deltasFormatted","delta","push","getReceivedByAddress","importAddresses","request","scriptPubKey","timestamp","getTransactionHex","transactionHash","generateBlock","lastLongest","blocksPassed","Promise","resolve","reject","infoInterval","setInterval","longestchain","clearInterval","getBlockByHash","blockHash","includeTx","data","name","message","includes","attrs","BlockNotFoundError","hash","number","difficulty","size","parentHash","nonce","transactionHashes","transactions","txs","getTransactionByHash","all","parseFloat","toFixed","getBlockByNumber","blockNumber","getBlockHeight","getParsedTransactionByHash","TxNotFoundError","getTransactionFee","tx","vin","coinbase","inputs","txid","vout","input","inputTransactions","inputValues","inputTx","index","inputValue","a","b","outputValue","minus","addFees","normalizeTransactionObject","undefined","confirmations","blockhash","getRawTransactionByHash","sendRawTransaction","sendBatchTransaction","outputs","to","dividedBy","createRawTransaction","rawTxOutputs","fundRawTransaction","rawTxFunded","signRawTransaction","hex","rawTxSigned","hexstring","JsonRpcProvider","VerusRpcProvider","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}