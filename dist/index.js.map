{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@liquality/verus-swap-provider/./lib/VerusSwapProvider.ts","webpack://@liquality/verus-swap-provider/./lib/index.ts","webpack://@liquality/verus-swap-provider/external commonjs \"@liquality/bitcoin-utils\"","webpack://@liquality/verus-swap-provider/external commonjs \"@liquality/provider\"","webpack://@liquality/verus-swap-provider/external commonjs \"@liquality/types\"","webpack://@liquality/verus-swap-provider/external commonjs \"@liquality/utils\"","webpack://@liquality/verus-swap-provider/external commonjs \"bitcoinjs-lib\"","webpack://@liquality/verus-swap-provider/webpack/bootstrap","webpack://@liquality/verus-swap-provider/webpack/startup"],"sourcesContent":["import { Transaction, Address, bitcoin, BigNumber, SwapParams, SwapProvider } from '@liquality/types'\nimport { Provider } from '@liquality/provider'\nimport {\n  calculateFee,\n  decodeRawTransaction,\n  normalizeTransactionObject,\n  witnessStackToScriptWitness,\n  getPubKeyHash,\n  validateAddress\n} from '@liquality/bitcoin-utils'\nimport {\n  addressToString,\n  validateValue,\n  validateSecret,\n  validateSecretHash,\n  validateSecretAndHash,\n  validateExpiration\n} from '@liquality/utils'\nimport { VerusNetwork } from '@liquality/verus-networks'\n\nimport { Psbt, script as bScript, payments } from 'bitcoinjs-lib'\n\ninterface BitcoinSwapProviderOptions {\n  network: VerusNetwork\n  mode?: bitcoin.SwapMode\n}\n\nexport default class BitcoinSwapProvider extends Provider implements Partial<SwapProvider> {\n  _network: VerusNetwork\n  _mode: bitcoin.SwapMode\n\n  constructor(options: BitcoinSwapProviderOptions) {\n    super()\n    const { network, mode = bitcoin.SwapMode.P2WSH } = options\n    const swapModes = Object.values(bitcoin.SwapMode)\n    if (!swapModes.includes(mode)) {\n      throw new Error(`Mode must be one of ${swapModes.join(',')}`)\n    }\n    this._network = network\n    this._mode = mode\n  }\n\n  validateSwapParams(swapParams: SwapParams) {\n    validateValue(swapParams.value)\n    validateAddress(swapParams.recipientAddress, this._network)\n    validateAddress(swapParams.refundAddress, this._network)\n    validateSecretHash(swapParams.secretHash)\n    validateExpiration(swapParams.expiration)\n  }\n\n  getSwapOutput(swapParams: SwapParams) {\n    this.validateSwapParams(swapParams)\n\n    const secretHashBuff = Buffer.from(swapParams.secretHash, 'hex')\n    const recipientPubKeyHash = getPubKeyHash(addressToString(swapParams.recipientAddress), this._network)\n    const refundPubKeyHash = getPubKeyHash(addressToString(swapParams.refundAddress), this._network)\n    const OPS = bScript.OPS\n\n    const script = bScript.compile([\n      OPS.OP_IF,\n      OPS.OP_SIZE,\n      bScript.number.encode(32),\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_SHA256,\n      secretHashBuff,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      recipientPubKeyHash,\n      OPS.OP_ELSE,\n      bScript.number.encode(swapParams.expiration),\n      OPS.OP_CHECKLOCKTIMEVERIFY,\n      OPS.OP_DROP,\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      refundPubKeyHash,\n      OPS.OP_ENDIF,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG\n    ])\n\n    if (![97, 98].includes(Buffer.byteLength(script))) {\n      throw new Error('Invalid swap script')\n    }\n\n    return script\n  }\n\n  getSwapInput(sig: Buffer, pubKey: Buffer, isClaim: boolean, secret?: string) {\n    const OPS = bScript.OPS\n    const redeem = isClaim ? OPS.OP_TRUE : OPS.OP_FALSE\n    const secretParams = isClaim ? [Buffer.from(secret, 'hex')] : []\n\n    return bScript.compile([sig, pubKey, ...secretParams, redeem])\n  }\n\n  getSwapPaymentVariants(swapOutput: Buffer) {\n    const p2wsh = payments.p2wsh({\n      redeem: { output: swapOutput, network: this._network },\n      network: this._network\n    })\n    const p2shSegwit = payments.p2sh({\n      redeem: p2wsh,\n      network: this._network\n    })\n    const p2sh = payments.p2sh({\n      redeem: { output: swapOutput, network: this._network },\n      network: this._network\n    })\n\n    return {\n      [bitcoin.SwapMode.P2WSH]: p2wsh,\n      [bitcoin.SwapMode.P2SH_SEGWIT]: p2shSegwit,\n      [bitcoin.SwapMode.P2SH]: p2sh\n    }\n  }\n\n  async initiateSwap(swapParams: SwapParams, feePerByte: number) {\n    this.validateSwapParams(swapParams)\n\n    const swapOutput = this.getSwapOutput(swapParams)\n    const address = this.getSwapPaymentVariants(swapOutput)[this._mode].address\n    return this.client.chain.sendTransaction({\n      to: address,\n      value: swapParams.value,\n      fee: feePerByte\n    })\n  }\n\n  async fundSwap(): Promise<null> {\n    return null\n  }\n\n  async claimSwap(swapParams: SwapParams, initiationTxHash: string, secret: string, feePerByte: number) {\n    this.validateSwapParams(swapParams)\n    validateSecret(secret)\n    validateSecretAndHash(secret, swapParams.secretHash)\n    await this.verifyInitiateSwapTransaction(swapParams, initiationTxHash)\n\n    return this._redeemSwap(swapParams, initiationTxHash, true, secret, feePerByte)\n  }\n\n  async refundSwap(swapParams: SwapParams, initiationTxHash: string, feePerByte: number) {\n    this.validateSwapParams(swapParams)\n    await this.verifyInitiateSwapTransaction(swapParams, initiationTxHash)\n\n    return this._redeemSwap(swapParams, initiationTxHash, false, undefined, feePerByte)\n  }\n\n  async _redeemSwap(\n    swapParams: SwapParams,\n    initiationTxHash: string,\n    isClaim: boolean,\n    secret: string,\n    feePerByte: number\n  ) {\n    const address = isClaim ? swapParams.recipientAddress : swapParams.refundAddress\n    const swapOutput = this.getSwapOutput(swapParams)\n    return this._redeemSwapOutput(\n      initiationTxHash,\n      swapParams.value,\n      addressToString(address),\n      swapOutput,\n      swapParams.expiration,\n      isClaim,\n      secret,\n      feePerByte\n    )\n  }\n\n  async _redeemSwapOutput(\n    initiationTxHash: string,\n    value: BigNumber,\n    address: string,\n    swapOutput: Buffer,\n    expiration: number,\n    isClaim: boolean,\n    secret: string,\n    _feePerByte: number\n  ) {\n    const network = this._network\n    const swapPaymentVariants = this.getSwapPaymentVariants(swapOutput)\n\n    const initiationTxRaw = await this.getMethod('getRawTransactionByHash')(initiationTxHash)\n    const initiationTx = decodeRawTransaction(initiationTxRaw, this._network)\n\n    let swapVout\n    let paymentVariantName: string\n    let paymentVariant: payments.Payment\n    for (const vout of initiationTx.vout) {\n      const paymentVariantEntry = Object.entries(swapPaymentVariants).find(\n        ([, payment]) => payment.output.toString('hex') === vout.scriptPubKey.hex\n      )\n      const voutValue = new BigNumber(vout.value).times(1e8)\n      if (paymentVariantEntry && voutValue.eq(new BigNumber(value))) {\n        paymentVariantName = paymentVariantEntry[0]\n        paymentVariant = paymentVariantEntry[1]\n        swapVout = vout\n      }\n    }\n\n    if (!swapVout) {\n      throw new Error('Valid swap output not found')\n    }\n\n    const feePerByte = _feePerByte || (await this.getMethod('getFeePerByte')())\n\n    // TODO: Implement proper fee calculation that counts bytes in inputs and outputs\n    const txfee = calculateFee(1, 1, feePerByte)\n    const swapValue = new BigNumber(swapVout.value).times(1e8).toNumber()\n\n    if (swapValue - txfee < 0) {\n      throw new Error('Transaction amount does not cover fee.')\n    }\n\n    const psbt = new Psbt({ network })\n\n    if (!isClaim) {\n      psbt.setLocktime(expiration)\n    }\n\n    const isSegwit =\n      paymentVariantName === bitcoin.SwapMode.P2WSH || paymentVariantName === bitcoin.SwapMode.P2SH_SEGWIT\n\n    const input: any = {\n      hash: initiationTxHash,\n      index: swapVout.n,\n      sequence: 0\n    }\n\n    if (isSegwit) {\n      input.witnessUtxo = {\n        script: paymentVariant.output,\n        value: swapValue\n      }\n      input.witnessScript = swapPaymentVariants.p2wsh.redeem.output // Strip the push bytes (0020) off the script\n    } else {\n      input.nonWitnessUtxo = Buffer.from(initiationTxRaw, 'hex')\n      input.redeemScript = paymentVariant.redeem.output\n    }\n\n    const output = {\n      address: address,\n      value: swapValue - txfee\n    }\n\n    psbt.addInput(input)\n    psbt.addOutput(output)\n\n    const walletAddress: Address = await this.getMethod('getWalletAddress')(address)\n    const signedPSBTHex: string = await this.getMethod('signPSBT')(psbt.toBase64(), [\n      { index: 0, derivationPath: walletAddress.derivationPath }\n    ])\n    const signedPSBT = Psbt.fromBase64(signedPSBTHex, { network })\n\n    const sig = signedPSBT.data.inputs[0].partialSig[0].signature\n\n    const swapInput = this.getSwapInput(sig, Buffer.from(walletAddress.publicKey, 'hex'), isClaim, secret)\n    const paymentParams = { redeem: { output: swapOutput, input: swapInput, network }, network }\n    const paymentWithInput = isSegwit ? payments.p2wsh(paymentParams) : payments.p2sh(paymentParams)\n\n    const getFinalScripts = () => {\n      let finalScriptSig\n      let finalScriptWitness\n\n      // create witness stack\n      if (isSegwit) {\n        finalScriptWitness = witnessStackToScriptWitness(paymentWithInput.witness)\n      }\n\n      if (paymentVariantName === bitcoin.SwapMode.P2SH_SEGWIT) {\n        // Adds the necessary push OP (PUSH34 (00 + witness script hash))\n        const inputScript = bScript.compile([swapPaymentVariants.p2shSegwit.redeem.output])\n        finalScriptSig = inputScript\n      } else if (paymentVariantName === bitcoin.SwapMode.P2SH) {\n        finalScriptSig = paymentWithInput.input\n      }\n\n      return {\n        finalScriptSig,\n        finalScriptWitness\n      }\n    }\n\n    psbt.finalizeInput(0, getFinalScripts)\n\n    const hex = psbt.extractTransaction().toHex()\n    await this.getMethod('sendRawTransaction')(hex)\n    return normalizeTransactionObject(decodeRawTransaction(hex, this._network), txfee)\n  }\n\n  extractSwapParams(outputScript: string) {\n    const buffer = bScript.decompile(Buffer.from(outputScript, 'hex')) as Buffer[]\n    if (buffer.length !== 20) throw new Error('Invalid swap output script')\n    const secretHash = buffer[5].reverse().toString('hex')\n    const recipientPublicKey = buffer[9].reverse().toString('hex')\n    const expiration = parseInt(buffer[11].reverse().toString('hex'), 16)\n    const refundPublicKey = buffer[16].reverse().toString('hex')\n    return { recipientPublicKey, refundPublicKey, secretHash, expiration }\n  }\n\n  /**\n   * Only to be used for situations where transaction is trusted. e.g to bump fee\n   * DO NOT USE THIS TO VERIFY THE REDEEM\n   */\n  async UNSAFE_isSwapRedeemTransaction(transaction: Transaction<bitcoin.Transaction>) {\n    // eslint-disable-line\n    if (transaction._raw.vin.length === 1 && transaction._raw.vout.length === 1) {\n      const swapInput = transaction._raw.vin[0]\n      const inputScript = this.getInputScript(swapInput)\n      const initiationTransaction: Transaction<bitcoin.Transaction> = await this.getMethod('getTransactionByHash')(\n        transaction._raw.vin[0].txid\n      )\n      const scriptType = initiationTransaction._raw.vout[transaction._raw.vin[0].vout].scriptPubKey.type\n      if (['scripthash', 'witness_v0_scripthash'].includes(scriptType) && [4, 5].includes(inputScript.length))\n        return true\n    }\n    return false\n  }\n\n  async updateTransactionFee(tx: Transaction<bitcoin.Transaction> | string, newFeePerByte: number) {\n    const txHash = typeof tx === 'string' ? tx : tx.hash\n    const transaction: Transaction<bitcoin.Transaction> = await this.getMethod('getTransactionByHash')(txHash)\n    if (await this.UNSAFE_isSwapRedeemTransaction(transaction)) {\n      const swapInput = transaction._raw.vin[0]\n      const inputScript = this.getInputScript(swapInput)\n      const initiationTxHash = swapInput.txid\n      const initiationTx: Transaction<bitcoin.Transaction> = await this.getMethod('getTransactionByHash')(\n        initiationTxHash\n      )\n      const swapOutput = initiationTx._raw.vout[swapInput.vout]\n      const value = new BigNumber(swapOutput.value).times(1e8)\n      const address = transaction._raw.vout[0].scriptPubKey.addresses[0]\n      const isClaim = inputScript.length === 5\n      const secret = isClaim ? inputScript[2] : undefined\n      const outputScript = isClaim ? inputScript[4] : inputScript[3]\n      const { expiration } = this.extractSwapParams(outputScript)\n      return this._redeemSwapOutput(\n        initiationTxHash,\n        value,\n        address,\n        Buffer.from(outputScript, 'hex'),\n        expiration,\n        isClaim,\n        secret,\n        newFeePerByte\n      )\n    }\n    return this.getMethod('updateTransactionFee')(tx, newFeePerByte)\n  }\n\n  getInputScript(vin: bitcoin.Input) {\n    const inputScript = vin.txinwitness\n      ? vin.txinwitness\n      : bScript\n          .decompile(Buffer.from(vin.scriptSig.hex, 'hex'))\n          .map((b) => (Buffer.isBuffer(b) ? b.toString('hex') : b))\n    return inputScript as string[]\n  }\n\n  doesTransactionMatchRedeem(initiationTxHash: string, tx: Transaction<bitcoin.Transaction>, isRefund: boolean) {\n    const swapInput = tx._raw.vin.find((vin) => vin.txid === initiationTxHash)\n    if (!swapInput) return false\n    const inputScript = this.getInputScript(swapInput)\n    if (!inputScript) return false\n    if (isRefund) {\n      if (inputScript.length !== 4) return false\n    } else {\n      if (inputScript.length !== 5) return false\n    }\n    return true\n  }\n\n  doesTransactionMatchInitiation(swapParams: SwapParams, transaction: Transaction<bitcoin.Transaction>) {\n    const swapOutput = this.getSwapOutput(swapParams)\n    const swapPaymentVariants = this.getSwapPaymentVariants(swapOutput)\n    const vout = transaction._raw.vout.find((vout) =>\n      Object.values(swapPaymentVariants).find(\n        (payment) =>\n          payment.output.toString('hex') === vout.scriptPubKey.hex &&\n          new BigNumber(vout.value).times(1e8).eq(new BigNumber(swapParams.value))\n      )\n    )\n    return Boolean(vout)\n  }\n\n  async verifyInitiateSwapTransaction(swapParams: SwapParams, initiationTxHash: string) {\n    this.validateSwapParams(swapParams)\n\n    const initiationTransaction = await this.getMethod('getTransactionByHash')(initiationTxHash)\n    return this.doesTransactionMatchInitiation(swapParams, initiationTransaction)\n  }\n\n  async findSwapTransaction(\n    swapParams: SwapParams,\n    blockNumber: number,\n    predicate: (tx: Transaction<bitcoin.Transaction>) => boolean\n  ) {\n    // TODO: Are mempool TXs possible?\n    const block = await this.getMethod('getBlockByNumber')(blockNumber, true)\n    const swapTransaction = block.transactions.find(predicate)\n    return swapTransaction\n  }\n\n  async findInitiateSwapTransaction(swapParams: SwapParams, blockNumber: number) {\n    this.validateSwapParams(swapParams)\n\n    return this.getMethod('findSwapTransaction', false)(\n      swapParams,\n      blockNumber,\n      (tx: Transaction<bitcoin.Transaction>) => this.doesTransactionMatchInitiation(swapParams, tx)\n    )\n  }\n\n  async findClaimSwapTransaction(swapParams: SwapParams, initiationTxHash: string, blockNumber: number) {\n    this.validateSwapParams(swapParams)\n\n    const claimSwapTransaction: Transaction<bitcoin.Transaction> = await this.getMethod('findSwapTransaction', false)(\n      swapParams,\n      blockNumber,\n      (tx: Transaction<bitcoin.Transaction>) => this.doesTransactionMatchRedeem(initiationTxHash, tx, false)\n    )\n\n    if (claimSwapTransaction) {\n      const swapInput = claimSwapTransaction._raw.vin.find((vin) => vin.txid === initiationTxHash)\n      if (!swapInput) {\n        throw new Error('Claim input missing')\n      }\n      const inputScript = this.getInputScript(swapInput)\n      const secret = inputScript[2] as string\n      validateSecretAndHash(secret, swapParams.secretHash)\n      return {\n        ...claimSwapTransaction,\n        secret\n      }\n    }\n  }\n\n  async findRefundSwapTransaction(swapParams: SwapParams, initiationTxHash: string, blockNumber: number) {\n    this.validateSwapParams(swapParams)\n\n    const refundSwapTransaction = await this.getMethod('findSwapTransaction', false)(\n      swapParams,\n      blockNumber,\n      (tx: Transaction<bitcoin.Transaction>) => this.doesTransactionMatchRedeem(initiationTxHash, tx, true)\n    )\n    return refundSwapTransaction\n  }\n\n  async findFundSwapTransaction(): Promise<null> {\n    return null\n  }\n}\n","import VerusSwapProvider from './VerusSwapProvider'\n\nexport { VerusSwapProvider }\n","module.exports = require(\"@liquality/bitcoin-utils\");","module.exports = require(\"@liquality/provider\");","module.exports = require(\"@liquality/types\");","module.exports = require(\"@liquality/utils\");","module.exports = require(\"bitcoinjs-lib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(175);\n"],"names":["options","network","mode","bitcoin","SwapMode","P2WSH","swapModes","Object","values","includes","Error","join","_network","_mode","validateSwapParams","swapParams","validateValue","value","validateAddress","recipientAddress","this","refundAddress","validateSecretHash","secretHash","validateExpiration","expiration","getSwapOutput","secretHashBuff","Buffer","from","recipientPubKeyHash","getPubKeyHash","addressToString","refundPubKeyHash","OPS","script","compile","OP_IF","OP_SIZE","number","encode","OP_EQUALVERIFY","OP_SHA256","OP_DUP","OP_HASH160","OP_ELSE","OP_CHECKLOCKTIMEVERIFY","OP_DROP","OP_ENDIF","OP_CHECKSIG","byteLength","getSwapInput","sig","pubKey","isClaim","secret","redeem","OP_TRUE","OP_FALSE","secretParams","getSwapPaymentVariants","swapOutput","p2wsh","payments","output","p2shSegwit","p2sh","P2SH_SEGWIT","P2SH","initiateSwap","feePerByte","address","client","chain","sendTransaction","to","fee","fundSwap","claimSwap","initiationTxHash","validateSecret","validateSecretAndHash","verifyInitiateSwapTransaction","_redeemSwap","refundSwap","undefined","_redeemSwapOutput","_feePerByte","swapPaymentVariants","getMethod","initiationTxRaw","initiationTx","decodeRawTransaction","vout","paymentVariantEntry","entries","find","toString","scriptPubKey","hex","voutValue","BigNumber","times","eq","paymentVariantName","paymentVariant","swapVout","txfee","calculateFee","swapValue","toNumber","psbt","Psbt","setLocktime","isSegwit","input","hash","index","n","sequence","witnessUtxo","witnessScript","nonWitnessUtxo","redeemScript","addInput","addOutput","walletAddress","toBase64","derivationPath","signedPSBTHex","signedPSBT","fromBase64","data","inputs","partialSig","signature","swapInput","publicKey","paymentParams","paymentWithInput","getFinalScripts","finalScriptSig","finalScriptWitness","witnessStackToScriptWitness","witness","finalizeInput","extractTransaction","toHex","normalizeTransactionObject","extractSwapParams","outputScript","buffer","decompile","length","reverse","recipientPublicKey","parseInt","refundPublicKey","UNSAFE_isSwapRedeemTransaction","transaction","_raw","vin","inputScript","getInputScript","txid","initiationTransaction","scriptType","type","updateTransactionFee","tx","newFeePerByte","txHash","addresses","txinwitness","scriptSig","map","b","isBuffer","doesTransactionMatchRedeem","isRefund","doesTransactionMatchInitiation","payment","Boolean","findSwapTransaction","blockNumber","predicate","transactions","findInitiateSwapTransaction","findClaimSwapTransaction","claimSwapTransaction","findRefundSwapTransaction","findFundSwapTransaction","Provider","VerusSwapProvider","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}