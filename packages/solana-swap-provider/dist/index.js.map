{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@liquality/solana-swap-provider/./lib/SolanaSwapProvider.ts","webpack://@liquality/solana-swap-provider/./lib/index.ts","webpack://@liquality/solana-swap-provider/external commonjs \"@liquality/errors\"","webpack://@liquality/solana-swap-provider/external commonjs \"@liquality/provider\"","webpack://@liquality/solana-swap-provider/external commonjs \"@liquality/solana-utils\"","webpack://@liquality/solana-swap-provider/external commonjs \"@liquality/types\"","webpack://@liquality/solana-swap-provider/external commonjs \"@solana/web3.js\"","webpack://@liquality/solana-swap-provider/webpack/bootstrap","webpack://@liquality/solana-swap-provider/webpack/startup"],"sourcesContent":["import { BigNumber, SwapParams, SwapProvider, Transaction, TxStatus } from '@liquality/types'\nimport { Provider } from '@liquality/provider'\nimport { Keypair, SystemProgram, PublicKey, TransactionInstruction } from '@solana/web3.js'\nimport {\n  doesTransactionMatchInitiation,\n  createClaimBuffer,\n  createInitBuffer,\n  createRefundBuffer,\n  validateSwapParams\n} from '@liquality/solana-utils'\nimport { WalletError, TxNotFoundError, InvalidAddressError, StandardError } from '@liquality/errors'\nimport { SolanaNetwork } from '@liquality/solana-networks'\n\nexport default class SolanaSwapProvider extends Provider implements Partial<SwapProvider> {\n  private _network: SolanaNetwork\n\n  constructor(network: SolanaNetwork) {\n    super()\n    this._network = network\n  }\n\n  async getSwapSecret(claimTxHash: string): Promise<string> {\n    const transactionByHash = await this.getMethod('getTransactionByHash')(claimTxHash)\n\n    if (!transactionByHash) {\n      throw new TxNotFoundError(`Transaction with hash: ${claimTxHash} was not found`)\n    }\n\n    return transactionByHash?.secret\n  }\n\n  async initiateSwap(swapParams: SwapParams): Promise<Transaction> {\n    validateSwapParams(swapParams)\n\n    const signer = await this.getMethod('_getSigner')()\n\n    const { programId } = this._network\n\n    const { expiration, refundAddress, recipientAddress, value, secretHash } = swapParams\n\n    const initBuffer = createInitBuffer({\n      buyer: recipientAddress.toString(),\n      seller: refundAddress.toString(),\n      expiration,\n      secret_hash: secretHash,\n      value: value.toNumber()\n    })\n\n    const appAccount = new Keypair()\n    const lamportsForRent = await this.getMethod('_getMinimumBalanceForRentExemption')(initBuffer.length)\n\n    if (value.lt(lamportsForRent)) {\n      throw new WalletError(`Invalid amount. Cannot be less than ${lamportsForRent} LAMPORTS`)\n    }\n\n    const systemAccountInstruction = this._createStorageAccountInstruction(\n      signer,\n      appAccount,\n      value,\n      initBuffer.length,\n      programId\n    )\n\n    const transactionInstruction = this._createTransactionInstruction(signer, appAccount, programId, initBuffer)\n\n    return await this.getMethod('sendTransaction')({\n      instructions: [systemAccountInstruction, transactionInstruction],\n      accounts: [appAccount]\n    })\n  }\n\n  async claimSwap(swapParams: SwapParams, initiationTxHash: string, secret: string): Promise<Transaction> {\n    validateSwapParams(swapParams)\n\n    const [{ programId }, [initTransaction]] = await Promise.all([\n      this.getMethod('getConnectedNetwork')(),\n      this.getMethod('getTransactionReceipt')([initiationTxHash]),\n      this.verifyInitiateSwapTransaction(swapParams, initiationTxHash)\n    ])\n\n    const { buyer, programAccount } = initTransaction._raw\n\n    await this._checkIfProgramAccountExists(programAccount)\n\n    const appAccount = new PublicKey(programAccount)\n    const buyerAccount = new PublicKey(buyer)\n\n    const transactionInstruction = await this._collectLamports(\n      appAccount,\n      buyerAccount,\n      createClaimBuffer(secret),\n      programId\n    )\n\n    return await this.getMethod('sendTransaction')({\n      instructions: [transactionInstruction]\n    })\n  }\n\n  async refundSwap(swapParams: SwapParams, initiationTxHash: string): Promise<Transaction> {\n    validateSwapParams(swapParams)\n\n    const [{ programId }, [initTransaction]] = await Promise.all([\n      this.getMethod('getConnectedNetwork')(),\n      this.getMethod('getTransactionReceipt')([initiationTxHash]),\n      this.verifyInitiateSwapTransaction(swapParams, initiationTxHash)\n    ])\n\n    const { seller, programAccount } = initTransaction._raw\n\n    await this._checkIfProgramAccountExists(programAccount)\n\n    const appAccount = new PublicKey(programAccount)\n    const sellerAccount = new PublicKey(seller)\n\n    const transactionInstruction = await this._collectLamports(\n      appAccount,\n      sellerAccount,\n      createRefundBuffer(),\n      programId.toString()\n    )\n\n    return await this.getMethod('sendTransaction')({\n      instructions: [transactionInstruction]\n    })\n  }\n\n  async fundSwap(): Promise<null> {\n    return null\n  }\n\n  async verifyInitiateSwapTransaction(swapParams: SwapParams, initiationTxHash: string): Promise<boolean> {\n    const initTransaction = await this.getMethod('getTransactionByHash')(initiationTxHash)\n\n    if (initTransaction.status !== TxStatus.Success) {\n      throw new StandardError(`Status for transaction ${initiationTxHash} is ${initTransaction.status}`)\n    }\n\n    return doesTransactionMatchInitiation(swapParams, initTransaction._raw)\n  }\n\n  async _collectLamports(\n    appAccountPubkey: PublicKey,\n    recipient: PublicKey,\n    data: Uint8Array,\n    _programId: string\n  ): Promise<TransactionInstruction> {\n    const signer = await this.getMethod('_getSigner')()\n    const programId = new PublicKey(_programId)\n\n    return new TransactionInstruction({\n      keys: [\n        { pubkey: signer.publicKey, isSigner: true, isWritable: true },\n        { pubkey: appAccountPubkey, isSigner: false, isWritable: true },\n        { pubkey: recipient, isSigner: false, isWritable: true }\n      ],\n      programId,\n      data: Buffer.from(data)\n    })\n  }\n\n  _createStorageAccountInstruction(\n    signer: Keypair,\n    appAccount: Keypair,\n    lamports: BigNumber,\n    space: number,\n    _programId: string\n  ): TransactionInstruction {\n    const newAccountPubkey = appAccount.publicKey\n    const programId = new PublicKey(_programId)\n\n    return SystemProgram.createAccount({\n      fromPubkey: signer.publicKey,\n      newAccountPubkey,\n      lamports: lamports.toNumber(),\n      space,\n      programId\n    })\n  }\n\n  _createTransactionInstruction = (\n    signer: Keypair,\n    appAccount: Keypair,\n    _programId: string,\n    data: Uint8Array\n  ): TransactionInstruction => {\n    const programId = new PublicKey(_programId)\n\n    const transaction = new TransactionInstruction({\n      keys: [\n        { pubkey: signer.publicKey, isSigner: true, isWritable: true },\n        { pubkey: appAccount.publicKey, isSigner: false, isWritable: true }\n      ],\n      programId,\n      data: Buffer.from(data)\n    })\n\n    return transaction\n  }\n\n  async _checkIfProgramAccountExists(programAccount: string): Promise<boolean> {\n    const isExisting = await this.getMethod('_getAccountInfo')(programAccount)\n\n    if (!isExisting) {\n      throw new InvalidAddressError('AccountDoesNotExist')\n    }\n\n    return isExisting\n  }\n}\n","import SolanaSwapProvider from './SolanaSwapProvider'\nexport { SolanaSwapProvider }\n","module.exports = require(\"@liquality/errors\");","module.exports = require(\"@liquality/provider\");","module.exports = require(\"@liquality/solana-utils\");","module.exports = require(\"@liquality/types\");","module.exports = require(\"@solana/web3.js\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(175);\n"],"names":["network","_createTransactionInstruction","signer","appAccount","_programId","data","programId","PublicKey","TransactionInstruction","keys","pubkey","publicKey","isSigner","isWritable","Buffer","from","_network","getSwapSecret","claimTxHash","this","getMethod","transactionByHash","TxNotFoundError","secret","initiateSwap","swapParams","validateSwapParams","expiration","refundAddress","recipientAddress","value","secretHash","initBuffer","createInitBuffer","buyer","toString","seller","secret_hash","toNumber","Keypair","length","lamportsForRent","lt","WalletError","systemAccountInstruction","_createStorageAccountInstruction","transactionInstruction","instructions","accounts","claimSwap","initiationTxHash","Promise","all","verifyInitiateSwapTransaction","initTransaction","_raw","programAccount","_checkIfProgramAccountExists","buyerAccount","_collectLamports","createClaimBuffer","refundSwap","sellerAccount","createRefundBuffer","fundSwap","status","TxStatus","Success","StandardError","doesTransactionMatchInitiation","appAccountPubkey","recipient","lamports","space","newAccountPubkey","SystemProgram","createAccount","fromPubkey","isExisting","InvalidAddressError","Provider","SolanaSwapProvider","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}