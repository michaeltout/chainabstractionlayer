{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@liquality/client/./lib/Chain.ts","webpack://@liquality/client/./lib/Client.ts","webpack://@liquality/client/./lib/Swap.ts","webpack://@liquality/client/./lib/Wallet.ts","webpack://@liquality/client/./lib/index.ts","webpack://@liquality/client/external commonjs \"@liquality/crypto\"","webpack://@liquality/client/external commonjs \"@liquality/errors\"","webpack://@liquality/client/external commonjs \"@liquality/schema\"","webpack://@liquality/client/external commonjs \"@liquality/types\"","webpack://@liquality/client/external commonjs \"ajv\"","webpack://@liquality/client/external commonjs \"debug\"","webpack://@liquality/client/external commonjs \"lodash\"","webpack://@liquality/client/webpack/bootstrap","webpack://@liquality/client/webpack/startup"],"sourcesContent":["import { InvalidProviderResponseError } from '@liquality/errors'\nimport {\n  SendOptions,\n  Block,\n  Transaction,\n  FeeDetails,\n  ChainProvider,\n  FeeProvider,\n  BigNumber,\n  Address\n} from '@liquality/types'\nimport { isBoolean, isNumber, isString, isObject } from 'lodash'\n\nexport default class Chain implements ChainProvider, FeeProvider {\n  client: any\n\n  constructor(client: any) {\n    this.client = client\n  }\n\n  /** @inheritdoc */\n  async generateBlock(numberOfBlocks: number): Promise<void> {\n    if (!isNumber(numberOfBlocks)) {\n      throw new TypeError('First argument should be a number')\n    }\n\n    return this.client.getMethod('generateBlock')(numberOfBlocks)\n  }\n\n  /** @inheritdoc */\n  async getBlockByHash(blockHash: string, includeTx = false): Promise<Block> {\n    if (!isString(blockHash)) {\n      throw new TypeError('Block hash should be a string')\n    }\n\n    if (!isBoolean(includeTx)) {\n      throw new TypeError('Second parameter should be boolean')\n    }\n\n    const block = await this.client.getMethod('getBlockByHash')(blockHash, includeTx)\n    this.client.assertValidBlock(block)\n    return block\n  }\n\n  /** @inheritdoc */\n  async getBlockByNumber(blockNumber: number, includeTx = false): Promise<Block> {\n    if (!isNumber(blockNumber)) {\n      throw new TypeError('Invalid Block number')\n    }\n\n    if (!isBoolean(includeTx)) {\n      throw new TypeError('Second parameter should be boolean')\n    }\n\n    const block = await this.client.getMethod('getBlockByNumber')(blockNumber, includeTx)\n    this.client.assertValidBlock(block)\n    return block\n  }\n\n  /** @inheritdoc */\n  async getBlockHeight(): Promise<number> {\n    const blockHeight = await this.client.getMethod('getBlockHeight')()\n\n    if (!isNumber(blockHeight)) {\n      throw new InvalidProviderResponseError('Provider returned an invalid block height')\n    }\n\n    return blockHeight\n  }\n\n  /** @inheritdoc */\n  async getTransactionByHash(txHash: string): Promise<Transaction> {\n    if (!isString(txHash)) {\n      throw new TypeError('Transaction hash should be a string')\n    }\n\n    const transaction = await this.client.getMethod('getTransactionByHash')(txHash)\n    if (transaction) {\n      this.client.assertValidTransaction(transaction)\n    }\n\n    return transaction\n  }\n\n  /** @inheritdoc */\n  async getBalance(addresses: (string | Address)[]): Promise<BigNumber> {\n    const balance = await this.client.getMethod('getBalance')(addresses)\n\n    if (!BigNumber.isBigNumber(balance)) {\n      throw new InvalidProviderResponseError('Provider returned an invalid response')\n    }\n\n    return balance\n  }\n\n  /** @inheritdoc */\n  async sendTransaction(options: SendOptions): Promise<Transaction> {\n    const transaction = await this.client.getMethod('sendTransaction')(options)\n    this.client.assertValidTransaction(transaction)\n    return transaction\n  }\n\n  /** @inheritdoc */\n  async sendSweepTransaction(address: Address | string, fee?: number): Promise<Transaction> {\n    return this.client.getMethod('sendSweepTransaction')(address, fee)\n  }\n\n  /** @inheritdoc */\n  async updateTransactionFee(tx: string | Transaction, newFee: number): Promise<Transaction> {\n    if (isObject(tx)) {\n      this.client.assertValidTransaction(tx)\n    } else {\n      if (!isString(tx)) {\n        throw new TypeError('Transaction should be a string or object')\n      }\n    }\n\n    const transaction = await this.client.getMethod('updateTransactionFee')(tx, newFee)\n    this.client.assertValidTransaction(transaction)\n    return transaction\n  }\n\n  /** @inheritdoc */\n  async sendBatchTransaction(transactions: SendOptions[]): Promise<Transaction> {\n    return this.client.getMethod('sendBatchTransaction')(transactions)\n  }\n\n  /** @inheritdoc */\n  async sendRawTransaction(rawTransaction: string): Promise<string> {\n    const txHash = await this.client.getMethod('sendRawTransaction')(rawTransaction)\n\n    if (!isString(txHash)) {\n      throw new InvalidProviderResponseError('sendRawTransaction method should return a transaction id string')\n    }\n\n    return txHash\n  }\n\n  /** @inheritdoc */\n  async getFees(): Promise<FeeDetails> {\n    return this.client.getMethod('getFees')()\n  }\n}\n","import { Block as BlockSchema, Transaction as TransactionSchema } from '@liquality/schema'\nimport { Block, Transaction, IClient } from '@liquality/types'\nimport { Provider } from '@liquality/provider'\nimport {\n  DuplicateProviderError,\n  InvalidProviderError,\n  NoProviderError,\n  UnimplementedMethodError,\n  UnsupportedMethodError,\n  InvalidProviderResponseError\n} from '@liquality/errors'\n\nimport { find, findLast, findLastIndex, isFunction } from 'lodash'\nimport debug from 'debug'\nimport Ajv from 'ajv'\n\nimport Chain from './Chain'\nimport Wallet from './Wallet'\nimport Swap from './Swap'\n\nexport default class Client implements IClient {\n  static debug(namespace = '*') {\n    // if localStorage.DEBUG (browser)\n    // or process.env.DEBUG (node) is not set\n    // @ts-ignore\n    if (!debug.load()) {\n      ;(debug as any).enable(namespace)\n    }\n  }\n\n  _providers: Provider[]\n  version: string\n  validateTransaction: Ajv.ValidateFunction\n  validateBlock: Ajv.ValidateFunction\n  _chain: Chain\n  _wallet: Wallet\n  _swap: Swap\n\n  /**\n   * Client\n   * @param {Provider} [provider] - Data source/provider for the instance\n   * @param {string} [version] - Minimum blockchain node version to support\n   */\n  constructor(provider?: Provider, version?: string) {\n    /**\n     * @type {Array}\n     */\n    this._providers = []\n\n    /**\n     * @type {string}\n     */\n    this.version = version\n\n    if (provider) {\n      this.addProvider(provider)\n    }\n\n    const ajv = new Ajv()\n    this.validateTransaction = ajv.compile(TransactionSchema)\n    this.validateBlock = ajv.compile(BlockSchema)\n\n    this._chain = new Chain(this)\n    this._wallet = new Wallet(this)\n    this._swap = new Swap(this)\n  }\n\n  /**\n   * Add a provider\n   * @param {!Provider} provider - The provider instance or RPC connection string\n   * @return {Client} Returns instance of Client\n   * @throws {InvalidProviderError} When invalid provider is provider\n   * @throws {DuplicateProviderError} When same provider is added again\n   */\n  addProvider(provider: Provider) {\n    if (!isFunction(provider.setClient)) {\n      throw new InvalidProviderError('Provider should have \"setClient\" method')\n    }\n\n    const duplicate = find(this._providers, (_provider) => provider.constructor === _provider.constructor)\n\n    if (duplicate) {\n      throw new DuplicateProviderError('Duplicate provider')\n    }\n\n    provider.setClient(this)\n    this._providers.push(provider)\n\n    return this\n  }\n\n  /**\n   * Check the availability of a method.\n   * @param {!string} method - Name of the method to look for in the provider stack\n   * @param {boolean|object} [requestor=false] - If provided, it returns providers only\n   *  above the requestor in the stack.\n   * @return {Provider} Returns a provider instance associated with the requested method\n   * @throws {NoProviderError} When no provider is available in the stack.\n   * @throws {UnimplementedMethodError} When the requested method is not provided\n   *  by any provider above requestor in the provider stack\n   * @throws {UnsupportedMethodError} When requested method is not supported by\n   *  version specified\n   */\n  getProviderForMethod(method: string, requestor = false) {\n    if (this._providers.length === 0) {\n      throw new NoProviderError('No provider provided. Add a provider to the client')\n    }\n\n    let indexOfRequestor = requestor\n      ? findLastIndex(this._providers, (provider) => requestor.constructor === provider.constructor)\n      : this._providers.length\n\n    if (indexOfRequestor === -1) indexOfRequestor = 0\n\n    const provider = findLast(this._providers, (provider) => isFunction((<any>provider)[method]), indexOfRequestor - 1)\n\n    if (provider == null) {\n      throw new UnimplementedMethodError(`Unimplemented method \"${method}\"`)\n    }\n\n    if (isFunction((<any>provider)._checkMethodVersionSupport)) {\n      if (!(<any>provider)._checkMethodVersionSupport(method, this.version)) {\n        throw new UnsupportedMethodError(`Method \"${method}\" is not supported by version \"${this.version}\"`)\n      }\n    }\n\n    return provider\n  }\n\n  /**\n   * Helper method that returns method from a provider.\n   * @param {!string} method - Name of the method to look for in the provider stack\n   * @param {object} [requestor] - If provided, it returns method from providers only\n   *  above the requestor in the stack.\n   * @return {function} Returns method from provider instance associated with the requested method\n   */\n  getMethod(method: string, requestor?: any) {\n    const provider = this.getProviderForMethod(method, requestor)\n    return (<any>provider)[method].bind(provider)\n  }\n\n  assertValidTransaction(transaction: Transaction) {\n    if (!this.validateTransaction(transaction)) {\n      const { errors } = this.validateTransaction\n      throw new InvalidProviderResponseError(\n        `Provider returned an invalid transaction, \"${errors[0].dataPath}\" ${errors[0].message}`\n      )\n    }\n  }\n\n  assertValidBlock(block: Block) {\n    if (!this.validateBlock(block)) {\n      const { errors } = this.validateBlock\n      throw new InvalidProviderResponseError(\n        `Provider returned an invalid block, \"${errors[0].dataPath}\" ${errors[0].message}`\n      )\n    }\n  }\n\n  get chain() {\n    return this._chain\n  }\n\n  get wallet() {\n    return this._wallet\n  }\n\n  get swap() {\n    return this._swap\n  }\n}\n","import { sha256 } from '@liquality/crypto'\nimport { SwapParams, SwapProvider, Transaction } from '@liquality/types'\n\nexport default class Swap implements SwapProvider {\n  client: any\n\n  constructor(client: any) {\n    this.client = client\n  }\n\n  /** @inheritdoc */\n  async findInitiateSwapTransaction(swapParams: SwapParams, blockNumber?: number): Promise<Transaction> {\n    return this.client.getMethod('findInitiateSwapTransaction')(swapParams, blockNumber)\n  }\n\n  /** @inheritdoc */\n  async findClaimSwapTransaction(\n    swapParams: SwapParams,\n    initiationTxHash: string,\n    blockNumber?: number\n  ): Promise<Transaction> {\n    return this.client.getMethod('findClaimSwapTransaction')(swapParams, initiationTxHash, blockNumber)\n  }\n\n  /** @inheritdoc */\n  async findRefundSwapTransaction(\n    swapParams: SwapParams,\n    initiationTxHash: string,\n    blockNumber?: number\n  ): Promise<Transaction> {\n    return this.client.getMethod('findRefundSwapTransaction')(swapParams, initiationTxHash, blockNumber)\n  }\n\n  /** @inheritdoc */\n  async findFundSwapTransaction(\n    swapParams: SwapParams,\n    initiationTxHash: string,\n    blockNumber?: number\n  ): Promise<Transaction | null> {\n    return this.client.getMethod('findFundSwapTransaction')(swapParams, initiationTxHash, blockNumber)\n  }\n\n  /** @inheritdoc */\n  async generateSecret(message: string): Promise<string> {\n    try {\n      return this.client.getMethod('generateSecret')(message)\n    } catch (e) {\n      if (!(e.name === 'UnimplementedMethodError')) throw e\n    }\n    const address = (await this.client.getMethod('getAddresses')())[0]\n    const signedMessage = await this.client.getMethod('signMessage')(message, address.address)\n    const secret = sha256(signedMessage)\n    return secret\n  }\n\n  /** @inheritdoc */\n  async getSwapSecret(claimTxHash: string): Promise<string> {\n    return this.client.getMethod('getSwapSecret')(claimTxHash)\n  }\n\n  /** @inheritdoc */\n  async initiateSwap(swapParams: SwapParams, fee: number): Promise<Transaction> {\n    const transaction = await this.client.getMethod('initiateSwap')(swapParams, fee)\n    this.client.assertValidTransaction(transaction)\n    return transaction\n  }\n\n  /** @inheritdoc */\n  async fundSwap(swapParams: SwapParams, initiationTxHash: string, fee: number): Promise<Transaction | null> {\n    return this.client.getMethod('fundSwap')(swapParams, initiationTxHash, fee)\n  }\n\n  /** @inheritdoc */\n  verifyInitiateSwapTransaction(swapParams: SwapParams, initiationTxHash: string): Promise<boolean> {\n    return this.client.getMethod('verifyInitiateSwapTransaction')(swapParams, initiationTxHash)\n  }\n\n  /** @inheritdoc */\n  async claimSwap(swapParams: SwapParams, initiationTxHash: string, secret: string, fee: number): Promise<Transaction> {\n    if (!/[A-Fa-f0-9]{64}/.test(secret)) {\n      throw new TypeError('Secret should be a 32 byte hex string')\n    }\n\n    const transaction = await this.client.getMethod('claimSwap')(swapParams, initiationTxHash, secret, fee)\n    this.client.assertValidTransaction(transaction)\n    return transaction\n  }\n\n  /** @inheritdoc */\n  async refundSwap(swapParams: SwapParams, initiationTxHash: string, fee: number): Promise<Transaction> {\n    const transaction = await this.client.getMethod('refundSwap')(swapParams, initiationTxHash, fee)\n    this.client.assertValidTransaction(transaction)\n    return transaction\n  }\n\n  /** @inheritdoc */\n  get doesBlockScan(): boolean {\n    try {\n      return this.client.getMethod('doesBlockScan')()\n    } catch (e) {\n      if (!(e.name === 'UnimplementedMethodError')) throw e\n    }\n    return true\n  }\n}\n","import { InvalidProviderResponseError } from '@liquality/errors'\nimport { Address, WalletProvider } from '@liquality/types'\nimport { isArray } from 'lodash'\n\nexport default class Wallet implements WalletProvider {\n  client: any\n\n  constructor(client: any) {\n    this.client = client\n  }\n\n  /**\n   * Get addresses/accounts of the user.\n   * @param {number} [startingIndex] - Index to start\n   * @param {number} [numAddresses] - Number of addresses to retrieve\n   * @param {boolean} [change] - True for change addresses\n   * @return {Promise<Address[], InvalidProviderResponseError>} Resolves with a list\n   *  of addresses.\n   *  Rejects with InvalidProviderResponseError if provider's response is invalid.\n   */\n  async getAddresses(startingIndex?: number, numAddresses?: number, change?: boolean): Promise<Address[]> {\n    const addresses = await this.client.getMethod('getAddresses')(startingIndex, numAddresses, change)\n\n    if (!isArray(addresses)) {\n      throw new InvalidProviderResponseError('Provider returned an invalid response')\n    }\n\n    return addresses\n  }\n\n  /**\n   * Get used addresses/accounts of the user.\n   * @param {number} [numAddressPerCall] - Number of addresses to retrieve per call\n   * @return {Promise<Address[], InvalidProviderResponseError>} Resolves with a list\n   *  of addresses.\n   *  Rejects with InvalidProviderResponseError if provider's response is invalid.\n   */\n  async getUsedAddresses(numAddressPerCall?: number): Promise<Address[]> {\n    return this.client.getMethod('getUsedAddresses')(numAddressPerCall)\n  }\n\n  /**\n   * Get unused address/account of the user.\n   * @param {boolean} [change] - True for change addresses\n   * @param {number} [numAddressPerCall] - Number of addresses to retrieve per call\n   * @return {Promise<Address, InvalidProviderResponseError>} Resolves with a address\n   *  object.\n   *  Rejects with InvalidProviderResponseError if provider's response is invalid.\n   */\n  async getUnusedAddress(change?: boolean, numAddressPerCall?: number): Promise<Address> {\n    return this.client.getMethod('getUnusedAddress')(change, numAddressPerCall)\n  }\n\n  /**\n   * Sign a message.\n   * @param {!string} message - Message to be signed.\n   * @param {!string} from - The address from which the message is signed.\n   * @return {Promise<string>} Resolves with a signed message.\n   */\n  async signMessage(message: string, from: string): Promise<string> {\n    return this.client.getMethod('signMessage')(message, from)\n  }\n\n  /**\n   * Retrieve the network connected to by the wallet\n   * @return {Promise<any>} Resolves with the network object\n   */\n  async getConnectedNetwork(): Promise<any> {\n    return this.client.getMethod('getConnectedNetwork')()\n  }\n\n  /**\n   * Retrieve the availability status of the wallet\n   * @return {Promise<Boolean>} True if the wallet is available to use\n   */\n  async isWalletAvailable(): Promise<boolean> {\n    return this.client.getMethod('isWalletAvailable')()\n  }\n\n  /**\n   * Flag indicating if the wallet allows apps to update transaction fees\n   * @return {Promise<Boolean>} True if wallet accepts fee updating\n   */\n  get canUpdateFee(): boolean {\n    try {\n      return this.client.getMethod('canUpdateFee')()\n    } catch (e) {\n      if (!(e.name === 'UnimplementedMethodError')) throw e\n    }\n    return true\n  }\n\n  /**\n   * Retrieve the private key for the account\n   * @return {Promise<string>} Resolves with the key as a string\n   */\n  exportPrivateKey(): Promise<string> {\n    return this.client.getMethod('exportPrivateKey')()\n  }\n}\n","import Client from './Client'\n\nexport { Client }\n","module.exports = require(\"@liquality/crypto\");","module.exports = require(\"@liquality/errors\");","module.exports = require(\"@liquality/schema\");","module.exports = require(\"@liquality/types\");","module.exports = require(\"ajv\");","module.exports = require(\"debug\");","module.exports = require(\"lodash\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(175);\n"],"names":["client","this","generateBlock","numberOfBlocks","isNumber","TypeError","getMethod","getBlockByHash","blockHash","includeTx","isString","isBoolean","block","assertValidBlock","getBlockByNumber","blockNumber","getBlockHeight","blockHeight","InvalidProviderResponseError","getTransactionByHash","txHash","transaction","assertValidTransaction","getBalance","addresses","balance","BigNumber","isBigNumber","sendTransaction","options","sendSweepTransaction","address","fee","updateTransactionFee","tx","newFee","isObject","sendBatchTransaction","transactions","sendRawTransaction","rawTransaction","getFees","provider","version","_providers","addProvider","ajv","validateTransaction","compile","Transaction","validateBlock","Block","_chain","_wallet","_swap","debug","namespace","load","enable","isFunction","setClient","InvalidProviderError","find","_provider","constructor","DuplicateProviderError","push","getProviderForMethod","method","requestor","length","NoProviderError","indexOfRequestor","findLastIndex","findLast","UnimplementedMethodError","_checkMethodVersionSupport","UnsupportedMethodError","bind","errors","dataPath","message","findInitiateSwapTransaction","swapParams","findClaimSwapTransaction","initiationTxHash","findRefundSwapTransaction","findFundSwapTransaction","generateSecret","e","name","signedMessage","sha256","getSwapSecret","claimTxHash","initiateSwap","fundSwap","verifyInitiateSwapTransaction","claimSwap","secret","test","refundSwap","getAddresses","startingIndex","numAddresses","change","isArray","getUsedAddresses","numAddressPerCall","getUnusedAddress","signMessage","from","getConnectedNetwork","isWalletAvailable","exportPrivateKey","Client","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}