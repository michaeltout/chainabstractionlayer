{"version":3,"file":"index.js","mappings":"gRAAA,gBACA,YAsFE,EAAAA,OAtFK,UACP,gBAEA,SAASC,EAAMC,GACb,QAAKA,EAAIC,MAAM,qBAEHC,OAAOC,KAAKH,EAAK,OAAOI,SAAS,SAE9BJ,EAAIK,cAQrB,SAASC,EAAaC,GACpB,GAAIL,OAAOM,SAASD,GAAU,OAAOA,EAErC,cAAeA,GACb,IAAK,SACHA,EAAUR,EAAMQ,GAAWL,OAAOC,KAAKI,EAAS,OAASL,OAAOC,KAAKI,GACrE,MACF,IAAK,SACHA,EAAUL,OAAOC,KAAKM,KAAKC,UAAUH,IAIzC,QAAOL,OAAOM,SAASD,IAAWA,EASpC,SAASI,EAAUC,EAAmBL,GACpC,OAAO,UAAWK,EAAWN,EAAaC,IAAUH,SAAS,OAsD7D,EAAAS,OA3FK,UAiGL,EAAAd,MAAAA,EAFA,EAAAO,aAAAA,EADA,EAAAQ,QAjDF,SAAiBP,GACf,OAAOI,EAAU,UAAWJ,IA8C5B,EAAAQ,OAtCF,SAAgBR,GACd,OAAOI,EAAU,SAAUJ,IAsC3B,EAAAS,UA9BF,SAAmBT,GACjB,OAAOI,EAAU,YAAaJ,IAgC9B,EAAAU,YAtBF,SAAqBjB,EAAakB,GAChC,IAAIC,EAA6B,EAAdD,GAAmBlB,EAAIoB,OAG1C,OAFAD,GAAgBA,EAAe,EAExBnB,EAAIqB,SAASF,EAAc,O,QChFpCG,EAAOC,QAAUC,QAAQ,W,QCAzBF,EAAOC,QAAUC,QAAQ,S,QCAzBF,EAAOC,QAAUC,QAAQ,oBCCrBC,EAA2B,GCE3BC,EDCJ,SAASC,EAAoBC,GAE5B,IAAIC,EAAeJ,EAAyBG,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaN,QAGrB,IAAID,EAASG,EAAyBG,GAAY,CAGjDL,QAAS,IAOV,OAHAQ,EAAoBH,GAAUI,KAAKV,EAAOC,QAASD,EAAQA,EAAOC,QAASI,GAGpEL,EAAOC,QClBWI,CAAoB,K","sources":["webpack://@liquality/crypto/./lib/index.ts","webpack://@liquality/crypto/external commonjs \"bech32\"","webpack://@liquality/crypto/external commonjs \"bs58\"","webpack://@liquality/crypto/external commonjs \"crypto-hashing\"","webpack://@liquality/crypto/webpack/bootstrap","webpack://@liquality/crypto/webpack/startup"],"sourcesContent":["import cryptoHash from 'crypto-hashing'\nimport base58 from 'bs58'\nimport bech32 from 'bech32'\n\nfunction isHex(hex: string) {\n  if (!hex.match(/([0-9]|[a-f])/gim)) return false\n\n  const buf = Buffer.from(hex, 'hex').toString('hex')\n\n  return buf === hex.toLowerCase()\n}\n\n/**\n * Ensure message is in buffer format.\n * @param {string} message - any string.\n * @return {string} Returns Buffer.\n */\nfunction ensureBuffer(message: string | Buffer | any) {\n  if (Buffer.isBuffer(message)) return message\n\n  switch (typeof message) {\n    case 'string':\n      message = isHex(message) ? Buffer.from(message, 'hex') : Buffer.from(message)\n      break\n    case 'object':\n      message = Buffer.from(JSON.stringify(message))\n      break\n  }\n\n  return Buffer.isBuffer(message) ? message : false\n}\n\n/**\n * Get hash of a message in hex.\n * @param {!string} algorithm - Hashing algorithm.\n * @param {!string|Buffer} message - Message to be hashed.\n * @return {string} Returns the hash of a string.\n */\nfunction hashToHex(algorithm: string, message: string | Buffer) {\n  return cryptoHash(algorithm, ensureBuffer(message)).toString('hex')\n}\n\n/**\n * Get hash160 of message.\n * @param {!string|Buffer} message - message in string or Buffer.\n * @return {string} Returns the hash160 of a string.\n */\nfunction hash160(message: Buffer) {\n  return hashToHex('hash160', message)\n}\n\n/**\n * Get sha256 of message.\n * @param {!string|Buffer} message - message in string or Buffer.\n * @return {string} Returns the sha256 of a string.\n */\nfunction sha256(message: string | Buffer) {\n  return hashToHex('sha256', message)\n}\n\n/**\n * Get ripemd160 of message.\n * @param {!string|Buffer} message - message in string or Buffer.\n * @return {string} Returns the ripemd160 of a string.\n */\nfunction ripemd160(message: string | Buffer) {\n  return hashToHex('ripemd160', message)\n}\n\n/**\n * Pad a hex string with '0'\n * @param {string} hex - The hex string to pad.\n * @param {number} lengthBytes - The length of the final string in bytes\n * @return {string} Returns a padded string with length greater or equal to the given length\n *  rounded up to the nearest even number.\n */\nfunction padHexStart(hex: string, lengthBytes?: number) {\n  let lengthString = lengthBytes * 2 || hex.length\n  lengthString += lengthString % 2\n\n  return hex.padStart(lengthString, '0')\n}\n\nexport {\n  /**\n   * Base58 object with decode, decodeUnsafe, and encode functions.\n   */\n  base58,\n  /**\n   * Get bech32 of message.\n   * @param {!string} message - any string.\n   * @return {string} Returns the bech32 of a string.\n   */\n  bech32,\n  sha256,\n  ripemd160,\n  hash160,\n  ensureBuffer,\n  padHexStart,\n  isHex\n}\n","module.exports = require(\"bech32\");","module.exports = require(\"bs58\");","module.exports = require(\"crypto-hashing\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(175);\n"],"names":["base58","isHex","hex","match","Buffer","from","toString","toLowerCase","ensureBuffer","message","isBuffer","JSON","stringify","hashToHex","algorithm","bech32","hash160","sha256","ripemd160","padHexStart","lengthBytes","lengthString","length","padStart","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}