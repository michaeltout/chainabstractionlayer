{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@liquality/ethereum-swap-provider/./lib/EthereumSwapProvider.ts","webpack://@liquality/ethereum-swap-provider/./lib/index.ts","webpack://@liquality/ethereum-swap-provider/external commonjs \"@liquality/crypto\"","webpack://@liquality/ethereum-swap-provider/external commonjs \"@liquality/errors\"","webpack://@liquality/ethereum-swap-provider/external commonjs \"@liquality/ethereum-utils\"","webpack://@liquality/ethereum-swap-provider/external commonjs \"@liquality/provider\"","webpack://@liquality/ethereum-swap-provider/external commonjs \"@liquality/types\"","webpack://@liquality/ethereum-swap-provider/external commonjs \"@liquality/utils\"","webpack://@liquality/ethereum-swap-provider/webpack/bootstrap","webpack://@liquality/ethereum-swap-provider/webpack/startup"],"sourcesContent":["import { Provider } from '@liquality/provider'\nimport { padHexStart } from '@liquality/crypto'\nimport { SwapProvider, SwapParams, BigNumber, Transaction, Block, ethereum } from '@liquality/types'\nimport {\n  addressToString,\n  caseInsensitiveEqual,\n  validateValue,\n  validateSecret,\n  validateSecretHash,\n  validateSecretAndHash\n} from '@liquality/utils'\nimport { remove0x, hexToNumber, validateAddress, validateExpiration } from '@liquality/ethereum-utils'\nimport { PendingTxError, TxNotFoundError, BlockNotFoundError } from '@liquality/errors'\n\nexport default class EthereumSwapProvider extends Provider implements Partial<SwapProvider> {\n  createSwapScript(swapParams: SwapParams) {\n    this.validateSwapParams(swapParams)\n\n    const recipientAddress = remove0x(addressToString(swapParams.recipientAddress))\n    const refundAddress = remove0x(addressToString(swapParams.refundAddress))\n\n    const expirationHex = swapParams.expiration.toString(16)\n    const expirationSize = 5\n    const expirationEncoded = padHexStart(expirationHex, expirationSize) // Pad with 0. string length\n\n    const bytecode = [\n      // Constructor\n      '60',\n      'c9', // PUSH1 {contractSize}\n      '80', // DUP1\n      '60',\n      '0b', // PUSH1 0b\n      '60',\n      '00', // PUSH1 00\n      '39', // CODECOPY\n      '60',\n      '00', // PUSH1 00\n      'f3', // RETURN\n\n      // Contract\n      '60',\n      '20', // PUSH1 20\n\n      // Get secret\n      '80', // DUP1\n      '60',\n      '00', // PUSH1 00\n      '80', // DUP1\n      '37', // CALLDATACOPY\n\n      // SHA256\n      '60',\n      '21', // PUSH1 21\n      '81', // DUP2\n      '60',\n      '00', // PUSH1 00\n      '80', // DUP1\n      '60',\n      '02', // PUSH1 02\n      '61',\n      'ffff', //PUSH ffff gas units for sha256 execution\n      'f1', // CALL\n\n      // Validate input size\n      '36', // CALLDATASIZE\n      '60',\n      '20', // PUSH1 20 (32 bytes)\n      '14', // EQ\n      '16', // AND (input valid size AND sha256 success)\n\n      // Validate with secretHash\n      '7f',\n      swapParams.secretHash, // PUSH32 {secretHashEncoded}\n      '60',\n      '21', // PUSH1 21\n      '51', // MLOAD\n      '14', // EQ\n      '16', // AND (input valid size AND sha256 success) AND secret valid\n      // Redeem if secret is valid\n      '60',\n      '50', // PUSH1 {redeemDestination}\n      '57', // JUMPI\n\n      // Validate input size\n      '36', // CALLDATASIZE\n      '15', // ISZERO (input empty)\n      // Check time lock\n      '64',\n      expirationEncoded, // PUSH5 {expirationEncoded}\n      '42', // TIMESTAMP\n      '11', // GT\n      '16', // AND (input size 0 AND time lock expired)\n      // Refund if timelock passed\n      '60',\n      '8d', // PUSH1 {refundDestination}\n      '57',\n\n      'fe', // INVALID\n\n      '5b', // JUMPDEST\n      // emit Claim(bytes32 _secret)\n      '7f',\n      '8c1d64e3bd87387709175b9ef4e7a1d7a8364559fc0e2ad9d77953909a0d1eb3', // PUSH32 topic Keccak-256(Claim(bytes32))\n      '60',\n      '20', // PUSH1 20 (log length - 32)\n      '60',\n      '00', // PUSH1 00 (log offset - 0)\n      'a1', // LOG 1\n      '73',\n      recipientAddress, // PUSH20 {recipientAddressEncoded}\n      'ff', // SELF-DESTRUCT\n\n      '5b', // JUMPDEST\n      // emit Refund()\n      '7f',\n      '5d26862916391bf49478b2f5103b0720a842b45ef145a268f2cd1fb2aed55178', // PUSH32 topic Keccak-256(Refund())\n      '60',\n      '00', // PUSH1 00 (log length - 0)\n      '80', // DUP 1 (log offset)\n      'a1', // LOG 1\n      '73',\n      refundAddress, // PUSH20 {refundAddressEncoded}\n      'ff' // SELF-DESTRUCT\n    ]\n      .join('')\n      .toLowerCase()\n\n    if (Buffer.byteLength(bytecode) !== 424) {\n      throw new Error('Invalid swap script. Bytecode length incorrect.')\n    }\n\n    return bytecode\n  }\n\n  validateSwapParams(swapParams: SwapParams) {\n    validateValue(swapParams.value)\n    validateAddress(swapParams.recipientAddress)\n    validateAddress(swapParams.refundAddress)\n    validateSecretHash(swapParams.secretHash)\n    validateExpiration(swapParams.expiration)\n  }\n\n  async initiateSwap(swapParams: SwapParams, gasPrice: number) {\n    this.validateSwapParams(swapParams)\n\n    const bytecode = this.createSwapScript(swapParams)\n    return this.client.chain.sendTransaction({ to: null, value: swapParams.value, data: bytecode, fee: gasPrice })\n  }\n\n  async fundSwap(): Promise<null> {\n    return null\n  }\n\n  async claimSwap(swapParams: SwapParams, initiationTxHash: string, secret: string, gasPrice: number) {\n    validateSecret(secret)\n    validateSecretAndHash(secret, swapParams.secretHash)\n    await this.verifyInitiateSwapTransaction(swapParams, initiationTxHash)\n\n    const initiationTransactionReceipt = await this.getMethod('getTransactionReceipt')(initiationTxHash)\n    if (!initiationTransactionReceipt)\n      throw new PendingTxError(`Transaction receipt is not available: ${initiationTxHash}`)\n\n    await this.getMethod('assertContractExists')(initiationTransactionReceipt.contractAddress)\n\n    return this.client.chain.sendTransaction({\n      to: initiationTransactionReceipt.contractAddress,\n      value: new BigNumber(0),\n      data: secret,\n      fee: gasPrice\n    })\n  }\n\n  async refundSwap(swapParams: SwapParams, initiationTxHash: string, gasPrice: number) {\n    await this.verifyInitiateSwapTransaction(swapParams, initiationTxHash)\n\n    const initiationTransactionReceipt = await this.getMethod('getTransactionReceipt')(initiationTxHash)\n    if (!initiationTransactionReceipt)\n      throw new PendingTxError(`Transaction receipt is not available: ${initiationTxHash}`)\n\n    await this.getMethod('assertContractExists')(initiationTransactionReceipt.contractAddress)\n\n    return this.client.chain.sendTransaction({\n      to: initiationTransactionReceipt.contractAddress,\n      value: new BigNumber(0),\n      data: '',\n      fee: gasPrice\n    })\n  }\n\n  doesTransactionMatchInitiation(swapParams: SwapParams, transaction: Transaction<ethereum.Transaction>) {\n    const data = this.createSwapScript(swapParams)\n    return (\n      transaction._raw.to === null &&\n      remove0x(transaction._raw.input) === data &&\n      swapParams.value.eq(hexToNumber(transaction._raw.value))\n    )\n  }\n\n  doesTransactionMatchClaim(\n    transaction: Transaction<ethereum.Transaction>,\n    initiationTransactionReceipt: ethereum.TransactionReceipt\n  ) {\n    return (\n      caseInsensitiveEqual(transaction._raw.to, initiationTransactionReceipt.contractAddress) &&\n      remove0x(transaction._raw.input).length === 64\n    )\n  }\n\n  async verifyInitiateSwapTransaction(swapParams: SwapParams, initiationTxHash: string) {\n    this.validateSwapParams(swapParams)\n\n    const initiationTransaction = await this.getMethod('getTransactionByHash')(initiationTxHash)\n    if (!initiationTransaction) throw new TxNotFoundError(`Transaction not found: ${initiationTxHash}`)\n\n    const initiationTransactionReceipt: ethereum.TransactionReceipt = await this.getMethod('getTransactionReceipt')(\n      initiationTxHash\n    )\n    if (!initiationTransactionReceipt)\n      throw new PendingTxError(`Transaction receipt is not available: ${initiationTxHash}`)\n\n    const transactionMatchesSwapParams = this.doesTransactionMatchInitiation(swapParams, initiationTransaction)\n\n    return (\n      transactionMatchesSwapParams &&\n      initiationTransactionReceipt.contractAddress &&\n      initiationTransactionReceipt.status === '0x1'\n    )\n  }\n\n  async findSwapTransaction(blockNumber: number, predicate: (tx: Transaction<any>, block: Block) => boolean) {\n    const block: Block<Transaction<ethereum.Transaction>> = await this.getMethod('getBlockByNumber')(blockNumber, true)\n    if (!block) throw new BlockNotFoundError(`Block not found: ${blockNumber}`)\n\n    if (block) {\n      return block.transactions.find((tx) => predicate(tx, block))\n    }\n  }\n\n  async findInitiateSwapTransaction(swapParams: SwapParams, blockNumber: number) {\n    this.validateSwapParams(swapParams)\n\n    return this.findSwapTransaction(blockNumber, (transaction) =>\n      this.doesTransactionMatchInitiation(swapParams, transaction)\n    )\n  }\n\n  async findClaimSwapTransaction(swapParams: SwapParams, initiationTxHash: string, blockNumber: number) {\n    this.validateSwapParams(swapParams)\n\n    const initiationTransactionReceipt = await this.getMethod('getTransactionReceipt')(initiationTxHash)\n    if (!initiationTransactionReceipt)\n      throw new PendingTxError(`Transaction receipt is not available: ${initiationTxHash}`)\n\n    const transaction = await this.findSwapTransaction(blockNumber, (transaction) =>\n      this.doesTransactionMatchClaim(transaction, initiationTransactionReceipt)\n    )\n    if (!transaction) return\n\n    const transactionReceipt: ethereum.TransactionReceipt = await this.getMethod('getTransactionReceipt')(\n      transaction.hash\n    )\n    if (transactionReceipt && transactionReceipt.status === '0x1') {\n      const secret = await this.getSwapSecret(transaction.hash)\n      validateSecretAndHash(secret, swapParams.secretHash)\n      transaction.secret = secret\n      return transaction\n    }\n  }\n\n  async findFundSwapTransaction(): Promise<null> {\n    return null\n  }\n\n  async getSwapSecret(claimTxHash: string) {\n    const claimTransaction: Transaction<ethereum.Transaction> = await this.getMethod('getTransactionByHash')(\n      claimTxHash\n    )\n    return remove0x(claimTransaction._raw.input)\n  }\n\n  async findRefundSwapTransaction(swapParams: SwapParams, initiationTxHash: string, blockNumber: number) {\n    this.validateSwapParams(swapParams)\n\n    const initiationTransactionReceipt: ethereum.TransactionReceipt = await this.getMethod('getTransactionReceipt')(\n      initiationTxHash\n    )\n    if (!initiationTransactionReceipt)\n      throw new PendingTxError(`Transaction receipt is not available: ${initiationTxHash}`)\n\n    const refundSwapTransaction = await this.findSwapTransaction(\n      blockNumber,\n      (transaction, block) =>\n        caseInsensitiveEqual(transaction._raw.to, initiationTransactionReceipt.contractAddress) &&\n        transaction._raw.input === '0x' &&\n        block.timestamp >= swapParams.expiration\n    )\n    return refundSwapTransaction\n  }\n}\n","import EthereumSwapProvider from './EthereumSwapProvider'\n\nexport { EthereumSwapProvider }\n","module.exports = require(\"@liquality/crypto\");","module.exports = require(\"@liquality/errors\");","module.exports = require(\"@liquality/ethereum-utils\");","module.exports = require(\"@liquality/provider\");","module.exports = require(\"@liquality/types\");","module.exports = require(\"@liquality/utils\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(175);\n"],"names":["createSwapScript","swapParams","this","validateSwapParams","recipientAddress","remove0x","addressToString","refundAddress","expirationHex","expiration","toString","expirationEncoded","padHexStart","bytecode","secretHash","join","toLowerCase","Buffer","byteLength","Error","validateValue","value","validateAddress","validateSecretHash","validateExpiration","initiateSwap","gasPrice","client","chain","sendTransaction","to","data","fee","fundSwap","claimSwap","initiationTxHash","secret","validateSecret","validateSecretAndHash","verifyInitiateSwapTransaction","getMethod","initiationTransactionReceipt","PendingTxError","contractAddress","BigNumber","refundSwap","doesTransactionMatchInitiation","transaction","_raw","input","eq","hexToNumber","doesTransactionMatchClaim","caseInsensitiveEqual","length","initiationTransaction","TxNotFoundError","status","findSwapTransaction","blockNumber","predicate","block","BlockNotFoundError","transactions","find","tx","findInitiateSwapTransaction","findClaimSwapTransaction","hash","transactionReceipt","getSwapSecret","findFundSwapTransaction","claimTxHash","claimTransaction","findRefundSwapTransaction","timestamp","Provider","EthereumSwapProvider","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}