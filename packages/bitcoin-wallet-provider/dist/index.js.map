{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@liquality/bitcoin-wallet-provider/./lib/BitcoinWalletProvider.ts","webpack://@liquality/bitcoin-wallet-provider/./lib/index.ts","webpack://@liquality/bitcoin-wallet-provider/external commonjs \"@liquality/bitcoin-utils\"","webpack://@liquality/bitcoin-wallet-provider/external commonjs \"@liquality/errors\"","webpack://@liquality/bitcoin-wallet-provider/external commonjs \"@liquality/types\"","webpack://@liquality/bitcoin-wallet-provider/external commonjs \"@liquality/utils\"","webpack://@liquality/bitcoin-wallet-provider/external commonjs \"bitcoinjs-lib\"","webpack://@liquality/bitcoin-wallet-provider/external commonjs \"memoizee\"","webpack://@liquality/bitcoin-wallet-provider/webpack/bootstrap","webpack://@liquality/bitcoin-wallet-provider/webpack/startup"],"sourcesContent":["import {\n  selectCoins,\n  normalizeTransactionObject,\n  decodeRawTransaction,\n  CoinSelectTarget\n} from '@liquality/bitcoin-utils'\nimport { BitcoinNetwork } from '@liquality/bitcoin-networks'\nimport { bitcoin, Transaction, Address, BigNumber, SendOptions, ChainProvider, WalletProvider } from '@liquality/types'\nimport { asyncSetImmediate, addressToString } from '@liquality/utils'\nimport { Provider } from '@liquality/provider'\nimport { InsufficientBalanceError } from '@liquality/errors'\nimport { BIP32Interface, payments, script } from 'bitcoinjs-lib'\nimport memoize from 'memoizee'\n\nconst ADDRESS_GAP = 20\n\nexport enum AddressSearchType {\n  EXTERNAL,\n  CHANGE,\n  EXTERNAL_OR_CHANGE\n}\n\ntype DerivationCache = { [index: string]: Address }\n\ntype Constructor<T = unknown> = new (...args: any[]) => T\n\ninterface BitcoinWalletProviderOptions {\n  network: BitcoinNetwork\n  baseDerivationPath: string\n  addressType?: bitcoin.AddressType\n}\n\nexport default <T extends Constructor<Provider>>(superclass: T) => {\n  abstract class BitcoinWalletProvider extends superclass implements Partial<ChainProvider>, Partial<WalletProvider> {\n    _baseDerivationPath: string\n    _network: BitcoinNetwork\n    _addressType: bitcoin.AddressType\n    _derivationCache: DerivationCache\n\n    constructor(...args: any[]) {\n      const options = args[0] as BitcoinWalletProviderOptions\n      const { network, baseDerivationPath, addressType = bitcoin.AddressType.BECH32 } = options\n      const addressTypes = Object.values(bitcoin.AddressType)\n      if (!addressTypes.includes(addressType)) {\n        throw new Error(`addressType must be one of ${addressTypes.join(',')}`)\n      }\n\n      super(options)\n\n      this._baseDerivationPath = baseDerivationPath\n      this._network = network\n      this._addressType = addressType\n      this._derivationCache = {}\n    }\n\n    abstract baseDerivationNode(): Promise<BIP32Interface>\n    abstract _buildTransaction(\n      targets: bitcoin.OutputTarget[],\n      feePerByte?: number,\n      fixedInputs?: bitcoin.Input[]\n    ): Promise<{ hex: string; fee: number }>\n    abstract _buildSweepTransaction(\n      externalChangeAddress: string,\n      feePerByte?: number\n    ): Promise<{ hex: string; fee: number }>\n    abstract signPSBT(data: string, inputs: bitcoin.PsbtInputTarget[]): Promise<string>\n    abstract signBatchP2SHTransaction(\n      inputs: [{ inputTxHex: string; index: number; vout: any; outputScript: Buffer }],\n      addresses: string,\n      tx: any,\n      lockTime?: number,\n      segwit?: boolean\n    ): Promise<Buffer[]>\n\n    getDerivationCache() {\n      return this._derivationCache\n    }\n\n    sendOptionsToOutputs(transactions: SendOptions[]): bitcoin.OutputTarget[] {\n      const targets: bitcoin.OutputTarget[] = []\n\n      transactions.forEach((tx) => {\n        if (tx.to && tx.value && tx.value.gt(0)) {\n          targets.push({\n            address: addressToString(tx.to),\n            value: tx.value.toNumber()\n          })\n        }\n\n        if (tx.data) {\n          const scriptBuffer = script.compile([script.OPS.OP_RETURN, Buffer.from(tx.data, 'hex')])\n          targets.push({\n            value: 0,\n            script: scriptBuffer\n          })\n        }\n      })\n\n      return targets\n    }\n\n    async setDerivationCache(derivationCache: DerivationCache) {\n      const address = await this.getDerivationPathAddress(Object.keys(derivationCache)[0])\n      if (derivationCache[address.derivationPath].address !== address.address) {\n        throw new Error(`derivationCache at ${address.derivationPath} does not match`)\n      }\n      this._derivationCache = derivationCache\n    }\n\n    async buildTransaction(output: bitcoin.OutputTarget, feePerByte: number) {\n      return this._buildTransaction([output], feePerByte)\n    }\n\n    async buildBatchTransaction(outputs: bitcoin.OutputTarget[]) {\n      return this._buildTransaction(outputs)\n    }\n\n    async _sendTransaction(transactions: bitcoin.OutputTarget[], feePerByte?: number) {\n      const { hex, fee } = await this._buildTransaction(transactions, feePerByte)\n      await this.getMethod('sendRawTransaction')(hex)\n      return normalizeTransactionObject(decodeRawTransaction(hex, this._network), fee)\n    }\n\n    async sendTransaction(options: SendOptions) {\n      return this._sendTransaction(this.sendOptionsToOutputs([options]), options.fee)\n    }\n\n    async sendBatchTransaction(transactions: SendOptions[]) {\n      return this._sendTransaction(this.sendOptionsToOutputs(transactions))\n    }\n\n    async buildSweepTransaction(externalChangeAddress: string, feePerByte: number) {\n      return this._buildSweepTransaction(externalChangeAddress, feePerByte)\n    }\n\n    async sendSweepTransaction(externalChangeAddress: Address | string, feePerByte: number) {\n      const { hex, fee } = await this._buildSweepTransaction(addressToString(externalChangeAddress), feePerByte)\n      await this.getMethod('sendRawTransaction')(hex)\n      return normalizeTransactionObject(decodeRawTransaction(hex, this._network), fee)\n    }\n\n    async updateTransactionFee(tx: Transaction<bitcoin.Transaction> | string, newFeePerByte: number) {\n      const txHash = typeof tx === 'string' ? tx : tx.hash\n      const transaction: bitcoin.Transaction = (await this.getMethod('getTransactionByHash')(txHash))._raw\n      const fixedInputs = [transaction.vin[0]] // TODO: should this pick more than 1 input? RBF doesn't mandate it\n\n      const lookupAddresses = transaction.vout.map((vout) => vout.scriptPubKey.addresses[0])\n      const changeAddress = await this.findAddress(lookupAddresses, true)\n      const changeOutput = transaction.vout.find((vout) => vout.scriptPubKey.addresses[0] === changeAddress.address)\n\n      let outputs = transaction.vout\n      if (changeOutput) {\n        outputs = outputs.filter((vout) => vout.scriptPubKey.addresses[0] !== changeOutput.scriptPubKey.addresses[0])\n      }\n\n      // TODO more checks?\n      const transactions = outputs.map((output) => ({\n        address: output.scriptPubKey.addresses[0],\n        value: new BigNumber(output.value).times(1e8).toNumber()\n      }))\n      const { hex, fee } = await this._buildTransaction(transactions, newFeePerByte, fixedInputs)\n      await this.getMethod('sendRawTransaction')(hex)\n      return normalizeTransactionObject(decodeRawTransaction(hex, this._network), fee)\n    }\n\n    async findAddress(addresses: string[], change = false) {\n      // A maximum number of addresses to lookup after which it is deemed that the wallet does not contain this address\n      const maxAddresses = 5000\n      const addressesPerCall = 50\n      let index = 0\n      while (index < maxAddresses) {\n        const walletAddresses = await this.getAddresses(index, addressesPerCall, change)\n        const walletAddress = walletAddresses.find((walletAddr) =>\n          addresses.find((addr) => walletAddr.address === addr)\n        )\n        if (walletAddress) return walletAddress\n        index += addressesPerCall\n      }\n    }\n\n    async getWalletAddress(address: string) {\n      const externalAddress = await this.findAddress([address], false)\n      if (externalAddress) return externalAddress\n      const changeAddress = await this.findAddress([address], true)\n      if (changeAddress) return changeAddress\n\n      throw new Error('Wallet does not contain address')\n    }\n\n    getAddressFromPublicKey(publicKey: Buffer) {\n      return this.getPaymentVariantFromPublicKey(publicKey).address\n    }\n\n    getPaymentVariantFromPublicKey(publicKey: Buffer) {\n      if (this._addressType === bitcoin.AddressType.LEGACY) {\n        return payments.p2pkh({ pubkey: publicKey, network: this._network })\n      } else if (this._addressType === bitcoin.AddressType.P2SH_SEGWIT) {\n        return payments.p2sh({\n          redeem: payments.p2wpkh({ pubkey: publicKey, network: this._network }),\n          network: this._network\n        })\n      } else if (this._addressType === bitcoin.AddressType.BECH32) {\n        return payments.p2wpkh({ pubkey: publicKey, network: this._network })\n      }\n    }\n\n    async importAddresses() {\n      const change = await this.getAddresses(0, 200, true)\n      const nonChange = await this.getAddresses(0, 200, false)\n      const all = [...nonChange, ...change].map((address) => address.address)\n      await this.getMethod('importAddresses')(all)\n    }\n\n    async getDerivationPathAddress(path: string) {\n      if (path in this._derivationCache) {\n        return this._derivationCache[path]\n      }\n\n      const baseDerivationNode = await this.baseDerivationNode()\n      const subPath = path.replace(this._baseDerivationPath + '/', '')\n      const publicKey = baseDerivationNode.derivePath(subPath).publicKey\n      const address = this.getAddressFromPublicKey(publicKey)\n      const addressObject = new Address({\n        address,\n        publicKey: publicKey.toString('hex'),\n        derivationPath: path\n      })\n\n      this._derivationCache[path] = addressObject\n      return addressObject\n    }\n\n    async getAddresses(startingIndex = 0, numAddresses = 1, change = false) {\n      if (numAddresses < 1) {\n        throw new Error('You must return at least one address')\n      }\n\n      const addresses = []\n      const lastIndex = startingIndex + numAddresses\n      const changeVal = change ? '1' : '0'\n\n      for (let currentIndex = startingIndex; currentIndex < lastIndex; currentIndex++) {\n        const subPath = changeVal + '/' + currentIndex\n        const path = this._baseDerivationPath + '/' + subPath\n        const addressObject = await this.getDerivationPathAddress(path)\n        addresses.push(addressObject)\n\n        await asyncSetImmediate()\n      }\n\n      return addresses\n    }\n\n    async _getUsedUnusedAddresses(numAddressPerCall = 100, addressType: AddressSearchType) {\n      const usedAddresses = []\n      const addressCountMap = { change: 0, external: 0 }\n      const unusedAddressMap: { change: Address; external: Address } = { change: null, external: null }\n\n      let addrList: Address[]\n      let addressIndex = 0\n      let changeAddresses: Address[] = []\n      let externalAddresses: Address[] = []\n\n      /* eslint-disable no-unmodified-loop-condition */\n      while (\n        (addressType === AddressSearchType.EXTERNAL_OR_CHANGE &&\n          (addressCountMap.change < ADDRESS_GAP || addressCountMap.external < ADDRESS_GAP)) ||\n        (addressType === AddressSearchType.EXTERNAL && addressCountMap.external < ADDRESS_GAP) ||\n        (addressType === AddressSearchType.CHANGE && addressCountMap.change < ADDRESS_GAP)\n      ) {\n        /* eslint-enable no-unmodified-loop-condition */\n        addrList = []\n\n        if (\n          (addressType === AddressSearchType.EXTERNAL_OR_CHANGE || addressType === AddressSearchType.CHANGE) &&\n          addressCountMap.change < ADDRESS_GAP\n        ) {\n          // Scanning for change addr\n          changeAddresses = await this.getAddresses(addressIndex, numAddressPerCall, true)\n          addrList = addrList.concat(changeAddresses)\n        } else {\n          changeAddresses = []\n        }\n\n        if (\n          (addressType === AddressSearchType.EXTERNAL_OR_CHANGE || addressType === AddressSearchType.EXTERNAL) &&\n          addressCountMap.external < ADDRESS_GAP\n        ) {\n          // Scanning for non change addr\n          externalAddresses = await this.getAddresses(addressIndex, numAddressPerCall, false)\n          addrList = addrList.concat(externalAddresses)\n        }\n\n        const transactionCounts: bitcoin.AddressTxCounts = await this.getMethod('getAddressTransactionCounts')(addrList)\n\n        for (const address of addrList) {\n          const isUsed = transactionCounts[address.address] > 0\n          const isChangeAddress = changeAddresses.find((a) => address.address === a.address)\n          const key = isChangeAddress ? 'change' : 'external'\n\n          if (isUsed) {\n            usedAddresses.push(address)\n            addressCountMap[key] = 0\n            unusedAddressMap[key] = null\n          } else {\n            addressCountMap[key]++\n\n            if (!unusedAddressMap[key]) {\n              unusedAddressMap[key] = address\n            }\n          }\n        }\n\n        addressIndex += numAddressPerCall\n      }\n\n      return {\n        usedAddresses,\n        unusedAddress: unusedAddressMap\n      }\n    }\n\n    async getUsedAddresses(numAddressPerCall = 100) {\n      return this._getUsedUnusedAddresses(numAddressPerCall, AddressSearchType.EXTERNAL_OR_CHANGE).then(\n        ({ usedAddresses }) => usedAddresses\n      )\n    }\n\n    async getUnusedAddress(change = false, numAddressPerCall = 100) {\n      const addressType = change ? AddressSearchType.CHANGE : AddressSearchType.EXTERNAL\n      const key = change ? 'change' : 'external'\n      return this._getUsedUnusedAddresses(numAddressPerCall, addressType).then(\n        ({ unusedAddress }) => unusedAddress[key]\n      )\n    }\n\n    async withCachedUtxos(func: () => any) {\n      const originalGetMethod = this.getMethod\n      const memoizedGetFeePerByte = memoize(this.getMethod('getFeePerByte'), { primitive: true })\n      const memoizedGetUnspentTransactions = memoize(this.getMethod('getUnspentTransactions'), { primitive: true })\n      const memoizedGetAddressTransactionCounts = memoize(this.getMethod('getAddressTransactionCounts'), {\n        primitive: true\n      })\n      this.getMethod = (method: string, requestor: any = this) => {\n        if (method === 'getFeePerByte') return memoizedGetFeePerByte\n        if (method === 'getUnspentTransactions') return memoizedGetUnspentTransactions\n        else if (method === 'getAddressTransactionCounts') return memoizedGetAddressTransactionCounts\n        else return originalGetMethod.bind(this)(method, requestor)\n      }\n\n      const result = await func.bind(this)()\n\n      this.getMethod = originalGetMethod\n\n      return result\n    }\n\n    async getTotalFee(opts: SendOptions, max: boolean) {\n      const targets = this.sendOptionsToOutputs([opts])\n      if (!max) {\n        const { fee } = await this.getInputsForAmount(targets, opts.fee)\n        return fee\n      } else {\n        const { fee } = await this.getInputsForAmount(\n          targets.filter((t) => !t.value),\n          opts.fee,\n          [],\n          100,\n          true\n        )\n        return fee\n      }\n    }\n\n    async getTotalFees(transactions: SendOptions[], max: boolean) {\n      const fees = await this.withCachedUtxos(async () => {\n        const fees: { [index: number]: BigNumber } = {}\n        for (const tx of transactions) {\n          const fee = await this.getTotalFee(tx, max)\n          fees[tx.fee] = new BigNumber(fee)\n        }\n        return fees\n      })\n      return fees\n    }\n\n    async getInputsForAmount(\n      _targets: bitcoin.OutputTarget[],\n      feePerByte?: number,\n      fixedInputs: bitcoin.Input[] = [],\n      numAddressPerCall = 100,\n      sweep = false\n    ) {\n      let addressIndex = 0\n      let changeAddresses: Address[] = []\n      let externalAddresses: Address[] = []\n      const addressCountMap = {\n        change: 0,\n        nonChange: 0\n      }\n\n      const feePerBytePromise = this.getMethod('getFeePerByte')()\n      let utxos: bitcoin.UTXO[] = []\n\n      while (addressCountMap.change < ADDRESS_GAP || addressCountMap.nonChange < ADDRESS_GAP) {\n        let addrList: Address[] = []\n\n        if (addressCountMap.change < ADDRESS_GAP) {\n          // Scanning for change addr\n          changeAddresses = await this.getAddresses(addressIndex, numAddressPerCall, true)\n          addrList = addrList.concat(changeAddresses)\n        } else {\n          changeAddresses = []\n        }\n\n        if (addressCountMap.nonChange < ADDRESS_GAP) {\n          // Scanning for non change addr\n          externalAddresses = await this.getAddresses(addressIndex, numAddressPerCall, false)\n          addrList = addrList.concat(externalAddresses)\n        }\n\n        const fixedUtxos: bitcoin.UTXO[] = []\n        if (fixedInputs.length > 0) {\n          for (const input of fixedInputs) {\n            const txHex = await this.getMethod('getRawTransactionByHash')(input.txid)\n            const tx = decodeRawTransaction(txHex, this._network)\n            const value = new BigNumber(tx.vout[input.vout].value).times(1e8).toNumber()\n            const address = tx.vout[input.vout].scriptPubKey.addresses[0]\n            const walletAddress = await this.getWalletAddress(address)\n            const utxo = { ...input, value, address, derivationPath: walletAddress.derivationPath }\n            fixedUtxos.push(utxo)\n          }\n        }\n\n        if (!sweep || fixedUtxos.length === 0) {\n          const _utxos: bitcoin.UTXO[] = await this.getMethod('getUnspentTransactions')(addrList)\n          utxos.push(\n            ..._utxos.map((utxo) => {\n              const addr = addrList.find((a) => a.address === utxo.address)\n              return {\n                ...utxo,\n                derivationPath: addr.derivationPath\n              }\n            })\n          )\n        } else {\n          utxos = fixedUtxos\n        }\n\n        const utxoBalance = utxos.reduce((a, b) => a + (b.value || 0), 0)\n\n        const transactionCounts: bitcoin.AddressTxCounts = await this.getMethod('getAddressTransactionCounts')(addrList)\n\n        if (!feePerByte) feePerByte = await feePerBytePromise\n        const minRelayFee = await this.getMethod('getMinRelayFee')()\n        if (feePerByte < minRelayFee) {\n          throw new Error(`Fee supplied (${feePerByte} sat/b) too low. Minimum relay fee is ${minRelayFee} sat/b`)\n        }\n\n        let targets: CoinSelectTarget[]\n        if (sweep) {\n          const outputBalance = _targets.reduce((a, b) => a + (b['value'] || 0), 0)\n\n          const sweepOutputSize = 39\n          const paymentOutputSize = _targets.filter((t) => t.value && t.address).length * 39\n          const scriptOutputSize = _targets\n            .filter((t) => !t.value && t.script)\n            .reduce((size, t) => size + 39 + t.script.byteLength, 0)\n\n          const outputSize = sweepOutputSize + paymentOutputSize + scriptOutputSize\n          const inputSize = utxos.length * 153\n\n          const sweepFee = feePerByte * (inputSize + outputSize)\n          const amountToSend = new BigNumber(utxoBalance).minus(sweepFee)\n\n          targets = _targets.map((target) => ({ id: 'main', value: target.value, script: target.script }))\n          targets.push({ id: 'main', value: amountToSend.minus(outputBalance).toNumber() })\n        } else {\n          targets = _targets.map((target) => ({ id: 'main', value: target.value, script: target.script }))\n        }\n\n        const { inputs, outputs, change, fee } = selectCoins(utxos, targets, Math.ceil(feePerByte), fixedUtxos)\n\n        if (inputs && outputs) {\n          return {\n            inputs,\n            change,\n            outputs,\n            fee\n          }\n        }\n\n        for (const address of addrList) {\n          const isUsed = transactionCounts[address.address]\n          const isChangeAddress = changeAddresses.find((a) => address.address === a.address)\n          const key = isChangeAddress ? 'change' : 'nonChange'\n\n          if (isUsed) {\n            addressCountMap[key] = 0\n          } else {\n            addressCountMap[key]++\n          }\n        }\n\n        addressIndex += numAddressPerCall\n      }\n\n      throw new InsufficientBalanceError('Not enough balance')\n    }\n  }\n  return BitcoinWalletProvider\n}\n","import BitcoinWalletProvider from './BitcoinWalletProvider'\n\nexport { BitcoinWalletProvider }\n","module.exports = require(\"@liquality/bitcoin-utils\");","module.exports = require(\"@liquality/errors\");","module.exports = require(\"@liquality/types\");","module.exports = require(\"@liquality/utils\");","module.exports = require(\"bitcoinjs-lib\");","module.exports = require(\"memoizee\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(175);\n"],"names":["AddressSearchType","ADDRESS_GAP","superclass","options","args","network","baseDerivationPath","addressType","bitcoin","AddressType","BECH32","addressTypes","Object","values","includes","Error","join","_baseDerivationPath","_network","_addressType","_derivationCache","getDerivationCache","this","sendOptionsToOutputs","transactions","targets","forEach","tx","to","value","gt","push","address","addressToString","toNumber","data","scriptBuffer","script","compile","OPS","OP_RETURN","Buffer","from","setDerivationCache","derivationCache","getDerivationPathAddress","keys","derivationPath","buildTransaction","output","feePerByte","_buildTransaction","buildBatchTransaction","outputs","_sendTransaction","hex","fee","getMethod","normalizeTransactionObject","decodeRawTransaction","sendTransaction","sendBatchTransaction","buildSweepTransaction","externalChangeAddress","_buildSweepTransaction","sendSweepTransaction","updateTransactionFee","newFeePerByte","txHash","hash","transaction","_raw","fixedInputs","vin","lookupAddresses","vout","map","scriptPubKey","addresses","findAddress","changeAddress","changeOutput","find","filter","BigNumber","times","change","maxAddresses","addressesPerCall","index","getAddresses","walletAddresses","walletAddress","walletAddr","addr","getWalletAddress","externalAddress","getAddressFromPublicKey","publicKey","getPaymentVariantFromPublicKey","LEGACY","payments","p2pkh","pubkey","P2SH_SEGWIT","p2sh","redeem","p2wpkh","importAddresses","nonChange","all","path","baseDerivationNode","subPath","replace","derivePath","addressObject","Address","toString","startingIndex","numAddresses","lastIndex","changeVal","currentIndex","asyncSetImmediate","_getUsedUnusedAddresses","numAddressPerCall","usedAddresses","addressCountMap","external","unusedAddressMap","addressIndex","changeAddresses","externalAddresses","EXTERNAL_OR_CHANGE","EXTERNAL","CHANGE","addrList","concat","transactionCounts","isUsed","key","a","unusedAddress","getUsedAddresses","then","getUnusedAddress","withCachedUtxos","func","originalGetMethod","memoizedGetFeePerByte","primitive","memoizedGetUnspentTransactions","memoizedGetAddressTransactionCounts","method","requestor","bind","result","getTotalFee","opts","max","getInputsForAmount","t","getTotalFees","fees","_targets","sweep","feePerBytePromise","utxos","fixedUtxos","length","input","txid","txHex","utxo","_utxos","utxoBalance","reduce","b","minRelayFee","outputBalance","paymentOutputSize","scriptOutputSize","size","byteLength","outputSize","inputSize","sweepFee","amountToSend","minus","target","id","selectCoins","Math","ceil","inputs","InsufficientBalanceError","BitcoinWalletProvider","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}