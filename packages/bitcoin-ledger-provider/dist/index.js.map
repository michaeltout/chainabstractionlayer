{"version":3,"file":"index.js","mappings":"wgEAAA,aACA,SAEA,SACA,SACA,SACA,SACA,YACA,SACA,SAWA,cAIE,WAAYA,GAAZ,WACUC,EAAqFD,EAAO,QAAnFE,EAA4EF,EAAO,mBAA/D,EAAwDA,EAAO,YAA/DG,OAAW,IAAG,IAAAC,QAAQC,YAAYC,OAAM,EAAEC,EAAcP,EAAO,U,OACpG,cAAM,CAAEC,QAAO,EAAEC,mBAAkB,EAAEC,YAAW,EAAEK,IAAK,UAAcD,UAAS,EAAEE,kBAAmB,SAAQ,MACtGC,sBAAwB,G,EA0RjC,OAjSmD,OAU3C,YAAAC,YAAN,SAAkBC,EAAiBC,G,sGACrB,SAAMC,KAAKC,U,OACP,OADVC,EAAM,SACI,GAAMF,KAAKG,iBAAiBJ,I,OAEhC,OAFNK,EAAU,SACVC,EAAMC,OAAOP,KAAKD,GAASS,SAAS,OAC9B,GAAML,EAAIM,eAAeJ,EAAQK,eAAgBJ,I,OAC7D,MAAO,CAAP,GADMK,EAAM,UACDC,EAAID,EAAIE,WAGf,YAAAC,kBAAN,SACEC,EACAC,EACAC,G,2HAEY,SAAMhB,KAAKC,U,OAED,OAFhBC,EAAM,SAEU,GAAMF,KAAKiB,kBAAiB,I,OAClB,OAD1BC,EAAgB,SACU,GAAMlB,KAAKmB,mBAAmBL,EAASC,EAAYC,I,OAC9D,OADf,EAA0B,SAAxBI,EAAM,SAAEC,EAAM,SAAEC,EAAG,MACN,GAAMtB,KAAKuB,gBAAgBH,I,OAexB,OAflBI,EAAe,SACfC,EAAQL,EAAOM,KAAI,SAACC,GAAS,OAAAA,EAAKlB,kBAElCmB,EAAUd,EAAQY,KAAI,SAACG,GAC3B,IAAMC,EAAeD,EAAOE,QAAU,EAAA3B,QAAQ4B,eAAeH,EAAOzB,QAAS,EAAK6B,UAClF,MAAO,CAAEC,OAAQ,EAAKC,gBAAgBN,EAAOO,OAAQL,OAAQD,MAG3DT,GACFO,EAAQS,KAAK,CACXH,OAAQlC,KAAKmC,gBAAgBd,EAAOe,OACpCL,OAAQ,EAAA3B,QAAQ4B,eAAed,EAAcd,QAASJ,KAAKiC,YAIvC,GAAM/B,EAAIoC,4BAA4B,CAAEV,QAAO,IAAIrB,SAAS,Q,OAItE,OAJRgC,EAAkB,SAElBC,EAAW,CAAC,EAAAlD,QAAQC,YAAYC,OAAQ,EAAAF,QAAQC,YAAYkD,aAAaC,SAAS1C,KAAK2C,cAE/E,GAAMzC,EAAI0C,4BAA4B,CAElDxB,OAAQI,EACRqB,kBAAmBpB,EACnBqB,WAAY5B,EAAcT,eAC1B8B,gBAAe,EACfQ,OAAQP,EACRQ,yBAA0BR,EAC1BS,YAAajD,KAAK2C,eAAiB,EAAArD,QAAQC,YAAYC,OAAS,CAAC,UAAY,M,OAG/E,MAAO,CAAP,EAAO,CAAEa,IAXK,SAWOiB,IAAG,YAGpB,YAAA4B,SAAN,SAAeC,EAAc/B,G,mLAEf,OADNgC,EAAO,EAAAC,KAAKC,WAAWH,EAAM,CAAEhE,QAASa,KAAKiC,WACvC,GAAMjC,KAAKC,U,OAMvB,GANMC,EAAM,UAENqD,EAAkBH,EAAKI,SAASC,OAAM,SAACC,EAAOC,GAClD,OAAC,oBAAqB,aAAc,0BAA0BjB,SAASU,EAAKQ,aAAaD,SAGpEP,EAAKI,SAASK,SAAWzC,EAAOyC,OACrD,MAAM,IAAIC,MAAM,0F,OAGdP,EACmB,GAAMvD,KAAKuB,gBAC9B6B,EAAKI,SAAS9B,KAAI,SAACgC,GAAU,OAAGK,KAAML,EAAMM,KAAKC,UAAU1D,SAAS,OAAQ2D,KAAMR,EAAMC,YAFxF,O,OAamB,OAZf,EAAe,SAIfQ,EAAkB,SAAOT,GAAkB,qC,4DACjC,SAAM1D,KAAKoE,UAAU,0BAAfpE,CAA0C0D,EAAMM,KAAKC,UAAU1D,SAAS,S,OAGtE,OAHhB8D,EAAQ,SACRC,EAAK,EAAAC,qBAAqBF,EAAOrE,KAAKiC,UACtC7B,EAAUkE,EAAGJ,KAAKR,EAAMC,OAAOa,aAAaC,UAAU,GACtC,GAAMzE,KAAKG,iBAAiBC,I,OAClD,MAAO,CAAP,EADsB,kBAIH,GAAMsE,QAAQC,IAAIvB,EAAKI,SAAS9B,IAAIyC,K,OAWnC,OAXhBS,EAAe,SACfnD,EAAQmD,EAAalD,KAAI,SAACmD,GAAM,OAAAA,EAAEpE,kBAClC8B,EAAkBrC,EACrBoC,4BAA4B,CAC3BV,QAASwB,EAAK0B,UAAUpD,KAAI,SAACG,GAAW,OACtCE,OAAQF,EAAOE,OACfG,OAAQ,EAAKC,gBAAgBN,EAAOO,aAGvC7B,SAAS,OACN,EAAW,CAAC,EAAAjB,QAAQC,YAAYC,OAAQ,EAAAF,QAAQC,YAAYkD,aAAaC,SAAS1C,KAAK2C,cACvE,GAAM3C,KAAK+E,YAC/B3B,EAAK0B,UAAUpD,KAAI,SAACG,GAAW,OAAAA,EAAOzB,YACtC,I,OAGY,OALR4E,EAAgB,SAKR,GAAM9E,EAAI0C,4BAA4B,CAElDxB,OAAQ,EACRyB,kBAAmBpB,EACnBqB,WAAYkC,GAAiBA,EAAcvE,eAC3C8B,gBAAe,EACfQ,OAAQ,EACRC,yBAA0B,EAC1BC,YAAmC,WAAtBjD,KAAK2C,aAA4B,CAAC,UAAY,M,OARvD0B,EAAQ,SAWR,EAAoB,cAAqBY,QAAQZ,GAEvDjB,EAAK8B,WAAW,G,WACLxB,G,wDAYT,OAXMyB,EAAS,CACbhG,QAAS,EAAK8C,SACdmD,UAAW9E,OAAOP,KAAK6E,EAAalB,EAAMC,OAAOyB,UAAW,OAC5DC,KAAM,gD,iCAEJ,OADMC,EAAW,EAAkBC,IAAI7B,EAAMC,QAChC6B,QAAQ3B,OACZ,CAAP,EAAO,EAAA9B,OAAO0D,UAAUC,OAAOJ,EAASE,QAAQ,IAAIC,WACxC,CAAP,EAAOH,EAASvD,gBAI3B,GAAMqB,EAAKuC,eAAejC,EAAMC,MAAOwB,I,cAAvC,S,oBAZkB,EAAA/D,E,wBAAA,YAATsC,EAAK,K,KAALA,KAAe,M,wCAAN,I,aAepB,MAAO,CAAP,EAAON,EAAKwC,Y,QAGRpE,EAAe,GACfqE,EAAkB,GACpBrD,GAAW,E,IAEK,EAAApB,E,0BAAA,YAATsC,EAAK,KACQ,GAAM1D,KAAK8F,yBAAyBpC,EAAMjD,kBADxC,O,QAML,OALbsF,EAAgB,SACtBF,EAAgBxD,KAAK0D,GACf,EAAkC3C,EAAKD,KAAK/B,OAAOsC,EAAMC,OAAvDqC,EAAa,gBAAEC,EAAY,eAC7B,EAAyC7C,EAAKI,SAASE,EAAMC,OAArDuC,EAAS,OAASC,EAAU,QACpCrE,EAAekE,GAAiBC,EACnB,GAAMjG,KAAKoE,UAAU,0BAAfpE,CAA0CkG,EAAUjC,UAAU1D,SAAS,S,QAC1E,OADhB6F,EAAa,SACG,GAAMlG,EAAImG,iBAAiBD,GAAY,I,QAAvDE,EAAgB,SACtB9E,EAAaa,KAAK,CAACiE,EAAeH,EAAYrE,EAAavB,SAAS,OAAQ,IACxEyF,IAAexD,GAAW,G,0BATZ,I,eAaH,SAAMtC,EAAImG,iBAAiBjD,EAAKmD,QAAQC,KAAKC,SAAS,I,QACjD,OADhBC,EAAW,SACK,GAAMxG,EAAIoC,4BAA4BoE,I,QAEzC,OAFbC,EAAgB,SAEH,GAAMzG,EAAI0G,oBAAoB,CAE/CxF,OAAQI,EACRqB,kBAAmBgD,EAAgBnE,KAAI,SAACtB,GAAY,OAAAA,EAAQK,kBAC5D8B,gBAAiBoE,EAAcpG,SAAS,OACxCsG,SAAUzD,EAAK0D,SACf/D,OAAQP,EACRuE,mBAAoB,K,QAPhBC,EAAa,S,WAURtD,G,wDAWT,OAVMyB,EAAS,CACbhG,QAAS,EAAK8C,SACdmD,UAAW9E,OAAOP,KAAK8F,EAAgBnC,EAAMC,OAAOyB,UAAW,OAC/DC,KAAM,gD,iCAGJ,OAFM4B,EAAWzE,EAAWwE,EAAWtD,EAAMC,OAASqD,EAAWtD,EAAMC,OAAS,KAEzE,CAAP,EADsB,EAAA5B,OAAO0D,UAAUC,OAAOpF,OAAOP,KAAKkH,EAAU,QAAO,mBAK/E,GAAM7D,EAAKuC,eAAejC,EAAMC,MAAOwB,I,cAAvC,S,oBAXkB,EAAA/D,E,0BAAA,YAATsC,EAAK,K,KAALA,KAAe,O,2CAAN,I,eAcpB,MAAO,CAAP,EAAON,EAAKwC,oBAGR,YAAAsB,yBAAN,SACE9F,EACAqD,EACAH,EACAuC,EACA9D,G,wIAEY,SAAM/C,KAAKC,U,OAAjBC,EAAM,SAENiH,EAA+B,G,IACf,EAAA1C,E,wBAAA,YAAjB,OACmB,GAAMzE,KAAKG,iBAAiB,KADrB,M,OACvB4F,EAAgB,SACtBoB,EAA6B9E,KAAK0D,EAActF,gB,wBAF5B,I,aAKtB,IAAKsC,EACH,IAAK,EAAL,EAAoB,EAAA3B,EAAA,eAATsC,EAAK,KACdY,EAAG8C,eAAe1D,EAAMQ,KAAKmD,EAAG3D,EAAM5B,cAIzB,SAAM5B,EAAImG,iBAAiB/B,EAAGmC,SAAS,I,OACjC,OADjBC,EAAW,SACM,GAAMxG,EAAIoC,4BAA4BoE,I,OAAvDC,EAAiB,SAAiDpG,SAAS,OAE3EiB,EAAe,G,IACD,EAAAJ,E,wBAAA,YAATsC,EAAK,KACQ,GAAMxD,EAAImG,iBAAiB3C,EAAM0C,YAAY,KAD3C,O,OAClBE,EAAgB,SACtB9E,EAAaa,KAAK,CAACiE,EAAe5C,EAAMC,MAAOD,EAAM5B,aAAavB,SAAS,OAAQ,I,0BAFjE,I,cAKD,SAAML,EAAI0G,oBAAoB,CAE/CxF,OAAQI,EACRqB,kBAAmBsE,EACnB5E,gBAAiBoE,EACjBE,SAAQ,EACR9D,OAAM,EACNgE,mBAAoB,K,QAItB,IAXMC,EAAa,SAUbM,EAAkB,GACnB,EAAL,EAAwB,EAAAN,EAAA,eAAbO,EAAS,KACZN,EAAWlE,EAASwE,EAAYA,EAAY,KAClDD,EAAgBjF,KAAK/B,OAAOP,KAAKkH,EAAU,QAG7C,MAAO,CAAP,EAAOK,WAGT,YAAAnF,gBAAA,SAAgBD,GACd,IAAIsF,EAAY,IAAI,EAAAC,UAAUC,KAAKC,MAAMzF,IAAS3B,SAAS,IAG3D,OAFAiH,EAAY,EAAAI,YAAYJ,EAAW,GACflH,OAAOP,KAAKyH,EAAW,OACxBvD,WAGf,YAAA1C,gBAAN,SAAsBsG,G,uGACR,SAAM7H,KAAKC,U,OAEvB,OAFMC,EAAM,SAEL,CAAP,EAAOwE,QAAQC,IACbkD,EAAenG,KAAI,SAAOC,GAAI,qC,wDAChB,SAAM3B,KAAKoE,UAAU,oBAAfpE,CAAoC2B,EAAKoC,O,OAChD,OADL1D,EAAM,SACD,GAAMH,EAAImG,iBAAiBhG,GAAK,I,OAC3C,MAAO,CAAC,EAAD,CADI,SACCsB,EAAKuC,UAAM4D,EAAW,wBAKlC,YAAAC,oBAAN,SAA0BC,G,kGACZ,SAAMhI,KAAKC,U,OAEvB,OAFMC,EAAM,SACN+H,EAASjI,KAAK2C,eAAiB,EAAArD,QAAQC,YAAYkD,YAAc,OAASzC,KAAK2C,aAC9E,CAAP,EAAOzC,EAAIgI,mBAAmBF,EAAM,CAAEC,OAAM,aAGxC,YAAAC,mBAAN,SAAyBF,G,gGACvB,OAAIA,KAAQhI,KAAKJ,sBACR,CAAP,EAAOI,KAAKJ,sBAAsBoI,IAGZ,GAAMhI,KAAK+H,oBAAoBC,I,OAEvD,OAFMG,EAAkB,SACxBnI,KAAKJ,sBAAsBoI,GAAQG,EAC5B,CAAP,EAAOA,WAGH,YAAAC,mBAAN,W,kGACE,OAAIpI,KAAKqI,oBAA4B,CAAP,EAAOrI,KAAKqI,qBAErB,GAAMrI,KAAKkI,mBAAmBlI,KAAKsI,sB,OAOxD,OAPMC,EAAe,SACfC,EAAmB,EAAAC,eAAeF,EAAanD,WACrDpF,KAAKqI,oBAAsB,EAAAK,cACzBpI,OAAOP,KAAKyI,EAAkB,OAC9BlI,OAAOP,KAAKwI,EAAaI,UAAW,OACpC3I,KAAKiC,UAEA,CAAP,EAAOjC,KAAKqI,6BAGR,YAAAO,oBAAN,W,kGACuB,SAAM5I,KAAKkI,mBAAmBlI,KAAKsI,sB,OAGxD,OAHMC,EAAe,SACfpJ,EAAU,EAAA0J,kBAAkBN,EAAaO,gBAG7C9I,KAAKiC,SAAS8G,OAAS,EAAAC,gBAAgBC,gBAAgBF,MACvD5J,EAAQ4J,OAAS,EAAAC,gBAAgBE,gBAAgBH,KAE1C,CAAP,EAAO,EAAAC,gBAAgBC,iBAElB,CAAP,EAAO9J,WAEX,EAjSA,CAAmD,EAAAgK,sBAAsB,EAAAC,iB,qMCpBzE,eAES,EAAAC,sBAFF,W,QCAPC,EAAOC,QAAUC,QAAQ,yB,QCAzBF,EAAOC,QAAUC,QAAQ,gC,QCAzBF,EAAOC,QAAUC,QAAQ,6B,QCAzBF,EAAOC,QAAUC,QAAQ,uC,QCAzBF,EAAOC,QAAUC,QAAQ,sB,QCAzBF,EAAOC,QAAUC,QAAQ,+B,QCAzBF,EAAOC,QAAUC,QAAQ,qB,QCAzBF,EAAOC,QAAUC,QAAQ,U,QCAzBF,EAAOC,QAAUC,QAAQ,mBCCrBC,EAA2B,GCE3BC,EDCJ,SAASC,EAAoBC,GAE5B,IAAIC,EAAeJ,EAAyBG,GAC5C,QAAqB9B,IAAjB+B,EACH,OAAOA,EAAaN,QAGrB,IAAID,EAASG,EAAyBG,GAAY,CAGjDL,QAAS,IAOV,OAHAO,EAAoBF,GAAUG,KAAKT,EAAOC,QAASD,EAAQA,EAAOC,QAASI,GAGpEL,EAAOC,QClBWI,CAAoB,K","sources":["webpack://@liquality/bitcoin-ledger-provider/./lib/BitcoinLedgerProvider.ts","webpack://@liquality/bitcoin-ledger-provider/./lib/index.ts","webpack://@liquality/bitcoin-ledger-provider/external commonjs \"@ledgerhq/hw-app-btc\"","webpack://@liquality/bitcoin-ledger-provider/external commonjs \"@liquality/bitcoin-networks\"","webpack://@liquality/bitcoin-ledger-provider/external commonjs \"@liquality/bitcoin-utils\"","webpack://@liquality/bitcoin-ledger-provider/external commonjs \"@liquality/bitcoin-wallet-provider\"","webpack://@liquality/bitcoin-ledger-provider/external commonjs \"@liquality/crypto\"","webpack://@liquality/bitcoin-ledger-provider/external commonjs \"@liquality/ledger-provider\"","webpack://@liquality/bitcoin-ledger-provider/external commonjs \"@liquality/types\"","webpack://@liquality/bitcoin-ledger-provider/external commonjs \"bip32\"","webpack://@liquality/bitcoin-ledger-provider/external commonjs \"bitcoinjs-lib\"","webpack://@liquality/bitcoin-ledger-provider/webpack/bootstrap","webpack://@liquality/bitcoin-ledger-provider/webpack/startup"],"sourcesContent":["import { LedgerProvider } from '@liquality/ledger-provider'\nimport { BitcoinWalletProvider } from '@liquality/bitcoin-wallet-provider'\n\nimport { padHexStart } from '@liquality/crypto'\nimport { compressPubKey, getAddressNetwork, decodeRawTransaction } from '@liquality/bitcoin-utils'\nimport { BitcoinNetworks, BitcoinNetwork } from '@liquality/bitcoin-networks'\nimport { bitcoin, BigNumber } from '@liquality/types'\nimport HwAppBitcoin from '@ledgerhq/hw-app-btc'\nimport { fromPublicKey, BIP32Interface } from 'bip32'\nimport { address, Psbt, PsbtTxInput, Transaction as BitcoinJsTransaction, script } from 'bitcoinjs-lib'\n\ntype WalletProviderConstructor<T = LedgerProvider<HwAppBitcoin>> = new (...args: any[]) => T\n\ninterface BitcoinLedgerProviderOptions {\n  network: BitcoinNetwork\n  Transport: any\n  baseDerivationPath: string\n  addressType?: bitcoin.AddressType\n}\n\nexport default class BitcoinLedgerProvider extends BitcoinWalletProvider(LedgerProvider as WalletProviderConstructor) {\n  _walletPublicKeyCache: { [index: string]: any }\n  _baseDerivationNode: BIP32Interface\n\n  constructor(options: BitcoinLedgerProviderOptions) {\n    const { network, baseDerivationPath, addressType = bitcoin.AddressType.BECH32, Transport } = options\n    super({ network, baseDerivationPath, addressType, App: HwAppBitcoin, Transport, ledgerScrambleKey: 'BTC' })\n    this._walletPublicKeyCache = {}\n  }\n\n  async signMessage(message: string, from: string) {\n    const app = await this.getApp()\n    const address = await this.getWalletAddress(from)\n    const hex = Buffer.from(message).toString('hex')\n    const sig = await app.signMessageNew(address.derivationPath, hex)\n    return sig.r + sig.s\n  }\n\n  async _buildTransaction(\n    targets: bitcoin.OutputTarget[],\n    feePerByte?: number,\n    fixedInputs?: bitcoin.Input[]\n  ): Promise<{ hex: string; fee: number }> {\n    const app = await this.getApp()\n\n    const unusedAddress = await this.getUnusedAddress(true)\n    const { inputs, change, fee } = await this.getInputsForAmount(targets, feePerByte, fixedInputs)\n    const ledgerInputs = await this.getLedgerInputs(inputs)\n    const paths = inputs.map((utxo) => utxo.derivationPath)\n\n    const outputs = targets.map((output) => {\n      const outputScript = output.script || address.toOutputScript(output.address, this._network)\n      return { amount: this.getAmountBuffer(output.value), script: outputScript }\n    })\n\n    if (change) {\n      outputs.push({\n        amount: this.getAmountBuffer(change.value),\n        script: address.toOutputScript(unusedAddress.address, this._network)\n      })\n    }\n\n    const outputScriptHex = await app.serializeTransactionOutputs({ outputs }).toString('hex')\n\n    const isSegwit = [bitcoin.AddressType.BECH32, bitcoin.AddressType.P2SH_SEGWIT].includes(this._addressType)\n\n    const txHex = await app.createPaymentTransactionNew({\n      // @ts-ignore\n      inputs: ledgerInputs,\n      associatedKeysets: paths,\n      changePath: unusedAddress.derivationPath,\n      outputScriptHex,\n      segwit: isSegwit,\n      useTrustedInputForSegwit: isSegwit,\n      additionals: this._addressType === bitcoin.AddressType.BECH32 ? ['bech32'] : []\n    })\n\n    return { hex: txHex, fee }\n  }\n\n  async signPSBT(data: string, inputs: bitcoin.PsbtInputTarget[]) {\n    const psbt = Psbt.fromBase64(data, { network: this._network })\n    const app = await this.getApp()\n\n    const inputsArePubkey = psbt.txInputs.every((input, index) =>\n      ['witnesspubkeyhash', 'pubkeyhash', 'p2sh-witnesspubkeyhash'].includes(psbt.getInputType(index))\n    )\n\n    if (inputsArePubkey && psbt.txInputs.length !== inputs.length) {\n      throw new Error('signPSBT: Ledger must sign all inputs when they are all regular pub key hash payments.')\n    }\n\n    if (inputsArePubkey) {\n      const ledgerInputs = await this.getLedgerInputs(\n        psbt.txInputs.map((input) => ({ txid: input.hash.reverse().toString('hex'), vout: input.index }))\n      )\n\n      const getInputDetails = async (input: PsbtTxInput) => {\n        const txHex = await this.getMethod('getRawTransactionByHash')(input.hash.reverse().toString('hex'))\n        const tx = decodeRawTransaction(txHex, this._network)\n        const address = tx.vout[input.index].scriptPubKey.addresses[0]\n        const walletAddress = await this.getWalletAddress(address)\n        return walletAddress\n      }\n\n      const inputDetails = await Promise.all(psbt.txInputs.map(getInputDetails))\n      const paths = inputDetails.map((i) => i.derivationPath)\n      const outputScriptHex = app\n        .serializeTransactionOutputs({\n          outputs: psbt.txOutputs.map((output) => ({\n            script: output.script,\n            amount: this.getAmountBuffer(output.value)\n          }))\n        })\n        .toString('hex')\n      const isSegwit = [bitcoin.AddressType.BECH32, bitcoin.AddressType.P2SH_SEGWIT].includes(this._addressType)\n      const changeAddress = await this.findAddress(\n        psbt.txOutputs.map((output) => output.address),\n        true\n      )\n\n      const txHex = await app.createPaymentTransactionNew({\n        // @ts-ignore\n        inputs: ledgerInputs,\n        associatedKeysets: paths,\n        changePath: changeAddress && changeAddress.derivationPath,\n        outputScriptHex,\n        segwit: isSegwit,\n        useTrustedInputForSegwit: isSegwit,\n        additionals: this._addressType === 'bech32' ? ['bech32'] : []\n      })\n\n      const signedTransaction = BitcoinJsTransaction.fromHex(txHex)\n\n      psbt.setVersion(1) // Ledger payment txs use v1 and there is no option to change it - fuck knows why\n      for (const input of inputs) {\n        const signer = {\n          network: this._network,\n          publicKey: Buffer.from(inputDetails[input.index].publicKey, 'hex'),\n          sign: async () => {\n            const sigInput = signedTransaction.ins[input.index]\n            if (sigInput.witness.length) {\n              return script.signature.decode(sigInput.witness[0]).signature\n            } else return sigInput.script\n          }\n        }\n\n        await psbt.signInputAsync(input.index, signer)\n      }\n\n      return psbt.toBase64()\n    }\n\n    const ledgerInputs = []\n    const walletAddresses = []\n    let isSegwit = false\n\n    for (const input of inputs) {\n      const walletAddress = await this.getDerivationPathAddress(input.derivationPath)\n      walletAddresses.push(walletAddress)\n      const { witnessScript, redeemScript } = psbt.data.inputs[input.index]\n      const { hash: inputHash, index: inputIndex } = psbt.txInputs[input.index]\n      const outputScript = witnessScript || redeemScript\n      const inputTxHex = await this.getMethod('getRawTransactionByHash')(inputHash.reverse().toString('hex'))\n      const ledgerInputTx = await app.splitTransaction(inputTxHex, true)\n      ledgerInputs.push([ledgerInputTx, inputIndex, outputScript.toString('hex'), 0])\n      if (witnessScript) isSegwit = true\n    }\n\n    // @ts-ignore - accessing private method required\n    const ledgerTx = await app.splitTransaction(psbt.__CACHE.__TX.toHex(), true)\n    const ledgerOutputs = await app.serializeTransactionOutputs(ledgerTx)\n\n    const ledgerSigs = await app.signP2SHTransaction({\n      // @ts-ignore\n      inputs: ledgerInputs,\n      associatedKeysets: walletAddresses.map((address) => address.derivationPath),\n      outputScriptHex: ledgerOutputs.toString('hex'),\n      lockTime: psbt.locktime,\n      segwit: isSegwit,\n      transactionVersion: 2\n    })\n\n    for (const input of inputs) {\n      const signer = {\n        network: this._network,\n        publicKey: Buffer.from(walletAddresses[input.index].publicKey, 'hex'),\n        sign: async () => {\n          const finalSig = isSegwit ? ledgerSigs[input.index] : ledgerSigs[input.index] + '01' // Is this a ledger bug? Why non segwit signs need the sighash appended?\n          const { signature } = script.signature.decode(Buffer.from(finalSig, 'hex'))\n          return signature\n        }\n      }\n\n      await psbt.signInputAsync(input.index, signer)\n    }\n\n    return psbt.toBase64()\n  }\n\n  async signBatchP2SHTransaction(\n    inputs: [{ inputTxHex: string; index: number; vout: any; outputScript: Buffer }],\n    addresses: string,\n    tx: any,\n    lockTime?: number,\n    segwit?: boolean\n  ): Promise<Buffer[]> {\n    const app = await this.getApp()\n\n    const walletAddressDerivationPaths = []\n    for (const address of addresses) {\n      const walletAddress = await this.getWalletAddress(address)\n      walletAddressDerivationPaths.push(walletAddress.derivationPath)\n    }\n\n    if (!segwit) {\n      for (const input of inputs) {\n        tx.setInputScript(input.vout.n, input.outputScript)\n      }\n    }\n\n    const ledgerTx = await app.splitTransaction(tx.toHex(), true)\n    const ledgerOutputs = (await app.serializeTransactionOutputs(ledgerTx)).toString('hex')\n\n    const ledgerInputs = []\n    for (const input of inputs) {\n      const ledgerInputTx = await app.splitTransaction(input.inputTxHex, true)\n      ledgerInputs.push([ledgerInputTx, input.index, input.outputScript.toString('hex'), 0])\n    }\n\n    const ledgerSigs = await app.signP2SHTransaction({\n      // @ts-ignore\n      inputs: ledgerInputs,\n      associatedKeysets: walletAddressDerivationPaths,\n      outputScriptHex: ledgerOutputs,\n      lockTime,\n      segwit,\n      transactionVersion: 2\n    })\n\n    const finalLedgerSigs = []\n    for (const ledgerSig of ledgerSigs) {\n      const finalSig = segwit ? ledgerSig : ledgerSig + '01'\n      finalLedgerSigs.push(Buffer.from(finalSig, 'hex'))\n    }\n\n    return finalLedgerSigs\n  }\n\n  getAmountBuffer(amount: number) {\n    let hexAmount = new BigNumber(Math.round(amount)).toString(16)\n    hexAmount = padHexStart(hexAmount, 8)\n    const valueBuffer = Buffer.from(hexAmount, 'hex')\n    return valueBuffer.reverse()\n  }\n\n  async getLedgerInputs(unspentOutputs: { txid: string; vout: number }[]) {\n    const app = await this.getApp()\n\n    return Promise.all(\n      unspentOutputs.map(async (utxo) => {\n        const hex = await this.getMethod('getTransactionHex')(utxo.txid)\n        const tx = await app.splitTransaction(hex, true)\n        return [tx, utxo.vout, undefined, 0]\n      })\n    )\n  }\n\n  async _getWalletPublicKey(path: string) {\n    const app = await this.getApp()\n    const format = this._addressType === bitcoin.AddressType.P2SH_SEGWIT ? 'p2sh' : this._addressType\n    return app.getWalletPublicKey(path, { format })\n  }\n\n  async getWalletPublicKey(path: string) {\n    if (path in this._walletPublicKeyCache) {\n      return this._walletPublicKeyCache[path]\n    }\n\n    const walletPublicKey = await this._getWalletPublicKey(path)\n    this._walletPublicKeyCache[path] = walletPublicKey\n    return walletPublicKey\n  }\n\n  async baseDerivationNode() {\n    if (this._baseDerivationNode) return this._baseDerivationNode\n\n    const walletPubKey = await this.getWalletPublicKey(this._baseDerivationPath)\n    const compressedPubKey = compressPubKey(walletPubKey.publicKey)\n    this._baseDerivationNode = fromPublicKey(\n      Buffer.from(compressedPubKey, 'hex'),\n      Buffer.from(walletPubKey.chainCode, 'hex'),\n      this._network\n    )\n    return this._baseDerivationNode\n  }\n\n  async getConnectedNetwork() {\n    const walletPubKey = await this.getWalletPublicKey(this._baseDerivationPath)\n    const network = getAddressNetwork(walletPubKey.bitcoinAddress)\n    // Bitcoin Ledger app does not distinguish between regtest & testnet\n    if (\n      this._network.name === BitcoinNetworks.bitcoin_regtest.name &&\n      network.name === BitcoinNetworks.bitcoin_testnet.name\n    ) {\n      return BitcoinNetworks.bitcoin_regtest\n    }\n    return network\n  }\n}\n","import BitcoinLedgerProvider from './BitcoinLedgerProvider'\n\nexport { BitcoinLedgerProvider }\n","module.exports = require(\"@ledgerhq/hw-app-btc\");","module.exports = require(\"@liquality/bitcoin-networks\");","module.exports = require(\"@liquality/bitcoin-utils\");","module.exports = require(\"@liquality/bitcoin-wallet-provider\");","module.exports = require(\"@liquality/crypto\");","module.exports = require(\"@liquality/ledger-provider\");","module.exports = require(\"@liquality/types\");","module.exports = require(\"bip32\");","module.exports = require(\"bitcoinjs-lib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(175);\n"],"names":["options","network","baseDerivationPath","addressType","bitcoin","AddressType","BECH32","Transport","App","ledgerScrambleKey","_walletPublicKeyCache","signMessage","message","from","this","getApp","app","getWalletAddress","address","hex","Buffer","toString","signMessageNew","derivationPath","sig","r","s","_buildTransaction","targets","feePerByte","fixedInputs","getUnusedAddress","unusedAddress","getInputsForAmount","inputs","change","fee","getLedgerInputs","ledgerInputs","paths","map","utxo","outputs","output","outputScript","script","toOutputScript","_network","amount","getAmountBuffer","value","push","serializeTransactionOutputs","outputScriptHex","isSegwit","P2SH_SEGWIT","includes","_addressType","createPaymentTransactionNew","associatedKeysets","changePath","segwit","useTrustedInputForSegwit","additionals","signPSBT","data","psbt","Psbt","fromBase64","inputsArePubkey","txInputs","every","input","index","getInputType","length","Error","txid","hash","reverse","vout","getInputDetails","getMethod","txHex","tx","decodeRawTransaction","scriptPubKey","addresses","Promise","all","inputDetails","i","txOutputs","findAddress","changeAddress","fromHex","setVersion","signer","publicKey","sign","sigInput","ins","witness","signature","decode","signInputAsync","toBase64","walletAddresses","getDerivationPathAddress","walletAddress","witnessScript","redeemScript","inputHash","inputIndex","inputTxHex","splitTransaction","ledgerInputTx","__CACHE","__TX","toHex","ledgerTx","ledgerOutputs","signP2SHTransaction","lockTime","locktime","transactionVersion","ledgerSigs","finalSig","signBatchP2SHTransaction","walletAddressDerivationPaths","setInputScript","n","finalLedgerSigs","ledgerSig","hexAmount","BigNumber","Math","round","padHexStart","unspentOutputs","undefined","_getWalletPublicKey","path","format","getWalletPublicKey","walletPublicKey","baseDerivationNode","_baseDerivationNode","_baseDerivationPath","walletPubKey","compressedPubKey","compressPubKey","fromPublicKey","chainCode","getConnectedNetwork","getAddressNetwork","bitcoinAddress","name","BitcoinNetworks","bitcoin_regtest","bitcoin_testnet","BitcoinWalletProvider","LedgerProvider","BitcoinLedgerProvider","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}